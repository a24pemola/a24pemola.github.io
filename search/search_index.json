{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"actividad_2.1/","title":"Practica 2.1","text":""},{"location":"actividad_2.1/#instalacion-y-configuracion-de-servidor-web-nginx","title":"Instalaci\u00f3n y configuraci\u00f3n de servidor web Nginx","text":"<p>Para instalar el servidor nginx en nuestra Debian, lo primero que hacemos es actualizar los repositorios y luego instalamos el paquete necesario:</p> <pre><code>sudo apt update\n\nsudo apt install nginx\n</code></pre> <p>Despu\u00e9s, verificamos que nginx se haya instalado y que est\u00e9 funcionando bien:</p> <pre><code>systemctl status nginx\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"actividad_2.1/#creacion-de-las-carpeta-del-sitio-web","title":"Creaci\u00f3n de las carpeta del sitio web","text":"<p>Al igual que en Apache, todos los archivos que ser\u00e1n parte de un sitio web servido por nginx se organizan en carpetas. Normalmente, estas carpetas est\u00e1n dentro de <code>/var/www</code>.</p> <p>Vamos a crear la carpeta donde estar\u00e1 nuestro sitio web o dominio:</p> <pre><code>sudo mkdir -p /var/www/nombre_web/html\n</code></pre> <p></p> <p>El \"nombre_web\" puede ser lo que quieras, sin espacios.</p> <p>Luego, dentro de esa carpeta <code>html</code>, clona este repositorio:</p> <p>https://github.com/cloudacademy/static-website-example</p> <p></p> <p>Tambi\u00e9n vamos a hacer que el propietario de esa carpeta y todo lo que est\u00e9 dentro sea el usuario <code>www-data</code>, que suele ser el usuario del servicio web:</p> <p><code>sudo chown -R www-data:www-data /var/www/nombre_web/html</code> </p> <p></p> <p>Le daremos los permisos adecuados para que no tengamos problemas de acceso no autorizado al entrar en el sitio web:</p> <p><code>sudo chmod -R 755 /var/www/nombre_web</code> </p> <p></p> <p>Para comprobar que el servidor est\u00e1 funcionando bien y sirviendo p\u00e1ginas correctamente, puedes acceder desde tu cliente a:</p> <p><code>http://IP-maq-virtual</code></p> <p>Deber\u00eda aparecer algo as\u00ed:</p> <p></p> <p>Lo que significar\u00e1 que est\u00e1 correcto hasta ahora.</p>"},{"location":"actividad_2.1/#configuracion-de-servidor-web-nginx","title":"Configuraci\u00f3n de servidor web NGINX","text":"<p>Para que Nginx pueda mostrar el contenido de nuestra web, necesitamos crear un bloque de servidor con las directivas adecuadas. En lugar de modificar el archivo de configuraci\u00f3n predeterminado, vamos a crear uno nuevo en <code>/etc/nginx/sites-available/nombre_web</code>:</p> <pre><code>sudo nano /etc/nginx/sites-available/vuestro_dominio \n</code></pre> <p>El contenido de ese archivo de configuraci\u00f3n ser\u00eda algo como esto:</p> <pre><code>server {\n        listen 80;\n        listen [::]:80;\n        root /ruta/absoluta/archivo/index;\n        index index.html index.htm index.nginx-debian.html;\n        server_name nombre_web;\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre> <p></p> <p>En la directiva <code>root</code>, tienes que poner la ruta completa donde est\u00e9 el archivo <code>index.html</code> de tu p\u00e1gina web, que se encuentra entre los archivos que ya hab\u00e9is descomprimido.</p> <p>Ahora vamos a crear un enlace simb\u00f3lico entre este archivo y el de los sitios habilitados, para que se active autom\u00e1ticamente:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/nombre_web /etc/nginx/sites-enabled/\n</code></pre> <p></p> <p>Y reiniciamos el servidor para aplicar la configuraci\u00f3n:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p>"},{"location":"actividad_2.1/#comprobaciones","title":"Comprobaciones","text":""},{"location":"actividad_2.1/#comprobacion-del-correcto-funcionamiento","title":"Comprobaci\u00f3n del correcto funcionamiento","text":"<p>Como todav\u00eda no tenemos un servidor DNS que traduzca los nombres a IPs, lo vamos a hacer manualmente. Editaremos el archivo <code>/etc/hosts</code> en nuestra m\u00e1quina anfitriona para que asocie la IP de la m\u00e1quina virtual con nuestro <code>server_name</code>.</p> <p>En Linux, este archivo est\u00e1 en <code>/etc/hosts</code>.</p> <p>En Windows lo encontrar\u00e1s en <code>C\\Windows\\System32\\drivers\\etc\\hosts</code>.</p> <p>Ah\u00ed, debemos a\u00f1adir la siguiente l\u00ednea:</p> <p><code>192.168.X.X nombre_web</code></p> <p>Reemplaza \"192.168.X.X\" por la IP de tu m\u00e1quina virtual.</p> <p></p> <p></p>"},{"location":"actividad_2.1/#comprobar-registros-del-servidor","title":"Comprobar registros del servidor","text":"<p>Aseg\u00farate de que las peticiones se est\u00e1n registrando bien en los archivos de logs, tanto las que salen bien como las que fallan:</p> <ul> <li><code>/var/log/nginx/access.log</code>: aqu\u00ed se registra cada solicitud que llega a tu servidor web, a menos que tengas Nginx configurado para otra cosa.</li> </ul> <p></p> <ul> <li><code>/var/log/nginx/error.log</code>: cualquier error que ocurra con Nginx se va a anotar en este archivo.</li> </ul> <p></p>"},{"location":"actividad_2.1/#configurar-servidor-sftp-en-debian","title":"Configurar servidor SFTP en Debian","text":"<p>Primero, vamos a instalarlo desde los repositorios:</p> <pre><code>sudo apt-get update\nsudo apt-get install vsftpd\n</code></pre> <p></p> <p>Ahora, vamos a crear una carpeta en tu home de Debian:</p> <pre><code>mkdir /home/nombre_usuario/ftp\n</code></pre> <p></p> <p>En la configuraci\u00f3n de vsftpd, indicaremos que esta carpeta ser\u00e1 el directorio al que se cambia vsftpd una vez que el usuario se conecta.</p> <p>Luego, vamos a crear los certificados de seguridad necesarios para a\u00f1adir una capa de cifrado a la conexi\u00f3n (algo parecido a HTTPS):</p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem\n</code></pre> <p></p> <p>Una vez hecho esto, pasamos a configurar vsftpd como tal. Usa el editor de texto que prefieras para editar el archivo de configuraci\u00f3n del servicio, por ejemplo con nano:</p> <pre><code>sudo nano /etc/vsftpd.conf\n</code></pre> <p>Primero, busca estas l\u00edneas en el archivo y elim\u00ednalas por completo:</p> <pre><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n</code></pre> <p></p> <p>Despu\u00e9s, a\u00f1ade estas l\u00edneas en su lugar:</p> <pre><code>rsa_cert_file=/etc/ssl/private/vsftpd.pem\nrsa_private_key_file=/etc/ssl/private/vsftpd.pem\nssl_enable=YES\nallow_anon_ssl=NO\nforce_local_data_ssl=YES\nforce_local_logins_ssl=YES\nssl_tlsv1=YES\nssl_sslv2=NO\nssl_sslv3=NO\nrequire_ssl_reuse=NO\nssl_ciphers=HIGH\n\nlocal_root=/home/nombre_usuario/ftp\n</code></pre> <p></p> <p>Finalmente, guarda los cambios y reinicia el servicio para que aplique la nueva configuraci\u00f3n:</p> <pre><code>sudo systemctl restart --now vsftpd\n</code></pre> <p></p> <p>Una vez terminada esta configuraci\u00f3n, ya podr\u00e1s acceder a tu servidor usando un cliente FTP como Filezilla de dos maneras:</p> <ul> <li> <p>Por el puerto 21 (el puerto por defecto de FTP, que es inseguro), pero utilizando certificados para cifrar los datos, haci\u00e9ndolo seguro.</p> </li> <li> <p>Usando el protocolo SFTP, que se dedica al intercambio de datos con una conexi\u00f3n parecida a SSH, usando el puerto 22.</p> </li> </ul> <p>En mi caso utilic\u00e9 el puerto 22 porque el 21 parec\u00eda dar m\u00e1s error.</p> <p>Despu\u00e9s de descargar un cliente FTP en tu ordenador, introduce los datos necesarios para conectarte a tu servidor FTP en Debian:</p> <p></p> <ul> <li> <p>IP de Debian (recuadro rojo)</p> </li> <li> <p>Nombre de usuario de Debian (recuadro verde)</p> </li> <li> <p>Contrase\u00f1a del usuario (recuadro fucsia)</p> </li> <li> <p>Puerto de conexi\u00f3n, que ser\u00e1 el 22 conectando por SFTP (recuadro marr\u00f3n)</p> </li> </ul> <p>Al usar las claves de SSH (como ya hicimos en la Pr\u00e1ctica 1), no necesitas poner la contrase\u00f1a, solo el nombre de usuario.</p> <p>Al conectarte con claves FTP con Conexi\u00f3n r\u00e1pida, te saldr\u00e1 el mismo aviso que cuando te conectaste por primera vez por SSH a Debian. Lo aceptas, ya que no hay ning\u00fan peligro.</p> <p>Te conectar\u00e1s directamente a la carpeta que especificamos en el archivo de configuraci\u00f3n: <code>/home/lara/ftp</code>.</p> <p></p> <p>Una vez conectado, en el lado izquierdo de la pantalla (tu ordenador) buscas una imagen cualquiera (por ejemplo). En el lado derecho (el servidor), busca la carpeta donde quieres subir el archivo. Con un doble clic o haciendo clic derecho &gt; subir, lo transfieres al servidor.</p> <p>Recuerda que tu sitio web debe estar en la carpeta <code>/var/www</code> y es necesario darle los permisos adecuados, como hicimos con el otro sitio web.</p>"},{"location":"actividad_2.1/#https","title":"HTTPS","text":"<p>En esta parte vamos a a\u00f1adir una capa extra de seguridad a nuestro servidor. Vamos a hacer que todos los sitios web que tengamos usen certificados SSL y que se acceda a ellos a trav\u00e9s de HTTPS.</p> <p>Para hacerlo, y como prueba, vamos a generar unos certificados autofirmados. Luego, en el archivo de configuraci\u00f3n de nuestros hosts virtuales (los sitios web que ya configuramos), cambiaremos los par\u00e1metros que hagan falta.</p> <p>Puedes buscar en Internet para guiarte y conseguir el resultado que necesitas.</p> <p>En mi caso, me ayud\u00e9 de internet y la ayuda de unos amigos programadores.</p>"},{"location":"actividad_2.1/#redireccion-http-a-https","title":"Redirecci\u00f3n HTTP a HTTPS","text":"<p>Cuando hayas terminado de habilitar HTTPS en tus sitios web, puedes pasar a esta tarea.</p> <p>F\u00edjate que con la configuraci\u00f3n actual, tu sitio web es accesible de dos formas al mismo tiempo: por el puerto 80 (HTTP, que es inseguro) y por el puerto 443 (HTTPS, que es seguro). Como queremos dejar todo bien configurado y sin posibles fallos de seguridad, el objetivo es que, si un usuario accede a tu sitio por el puerto 80 (HTTP), autom\u00e1ticamente se le redirija a HTTPS, en el puerto 443, por seguridad.</p> <p>Busca la informaci\u00f3n necesaria para hacer esta redirecci\u00f3n autom\u00e1tica ajustando tus archivos de configuraci\u00f3n de hosts virtuales.</p> <p>De nuevo, personalmente me ayud\u00e9 de internet y unos amigos programadores.</p> <p>Para finalmente, terminarlo:</p> <p></p> <p></p>"},{"location":"actividad_2.1/#cuestiones-finales","title":"Cuestiones finales","text":"<p>\u00bfQu\u00e9 pasa si no hago el link simb\u00f3lico entre <code>sites-available</code> y <code>sites-enabled</code> de mi sitio web?</p> <p>Si no haces el enlace simb\u00f3lico entre <code>sites-available</code> y <code>sites-enabled</code>, tu sitio web no estar\u00e1 activo y Nginx no lo reconocer\u00e1. Esto significa que no podr\u00e1s acceder a tu sitio a trav\u00e9s de la web, ya que Nginx no lo servir\u00e1. As\u00ed que es un paso importante para que tu sitio est\u00e9 disponible.</p> <p>\u00bfQu\u00e9 pasa si no le doy los permisos adecuados a <code>/var/www/nombre_web</code>?</p> <p>Si no le das los permisos adecuados a <code>/var/www/nombre_web</code>, tu servidor web no podr\u00e1 acceder a los archivos de tu sitio. Esto puede causar errores al intentar cargar la p\u00e1gina, y los usuarios ver\u00e1n mensajes de acceso denegado. En resumen, tu sitio no funcionar\u00e1 correctamente.</p>"},{"location":"actividad_2.2/","title":"Practica 2.2","text":""},{"location":"actividad_2.2/#autenticacion-en-nginx","title":"Autenticaci\u00f3n en Nginx","text":""},{"location":"actividad_2.2/#paquetes-necesarios","title":"Paquetes necesarios","text":"<p>Podemos usar la herramienta openssl para crear contrase\u00f1as.</p> <p>Se puede comprobar si la tenemos instalada con el siguiente comando:</p> <pre><code>dpkg -l | grep openssl\n</code></pre> <p>En mi caso, estaba instalado:</p> <p></p>"},{"location":"actividad_2.2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Crearemos un archivo oculto llamado \u201c.htpasswd\u201d en el directorio de configuraci\u00f3n <code>/etc/nginx</code> donde guardar nuestros usuarios y contrase\u00f1as (la -c es para crear el archivo): </p> <pre><code>sudo sh -c \"echo -n 'vuestro_nombre:' &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Y a continuaci\u00f3n creamos el password cifrado para el usuario:</p> <pre><code>sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Se pueden crear tantos usuarios como haga falta. Para este ejercicio, yo he creado dos, uno para mi nombre, y otro para mi apellido.</p> <p>Podemos comprobar que los usuarios y contrase\u00f1as est\u00e1n cifrados:</p> <pre><code>cat /etc/nginx/.htpasswd\n</code></pre> <p></p>"},{"location":"actividad_2.2/#configurando-el-servidor-nginx-para-usar-autenticacion-basica","title":"Configurando el servidor Nginx para usar autenticaci\u00f3n b\u00e1sica","text":"<p>Para poder proteger nuestra web teniendo que introducir el usuario y contrase\u00f1a, debemos modificar nuestro archivo en:</p> <pre><code>sudo nano /etc/nginx/sites-available/nombre_web\n</code></pre> <p></p> <p>Y a\u00f1adir <code>auth_basic</code> dentro de location, junto a <code>auth_basic_user_file</code> y el fichero que hemos creado anteriormente para las contrase\u00f1as.</p> <p></p> <p>Tras ello, debemos reiniciar el servicio para ue se apliquen los cambios y podamos comprobarlo:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p>"},{"location":"actividad_2.2/#probando-la-nueva-configuracion","title":"Probando la nueva configuraci\u00f3n","text":"<p>Al intentar ahora entrar a la web desde mi m\u00e1quina, pide un usuario y contrase\u00f1a:</p> <p></p> <p>Si se cancela, se denega el acceso a la misma:</p> <p></p> <p>Para la Tarea 1 se ha probado con un usuario bueno y otro err\u00f3neo, y comprobando los logs de <code>access.log</code> se pueden ver los logins de los que han podido entrar con \u00e9xito:</p> <p></p> <p>Y si comprobamos los logs de <code>error.log</code> podemos ver los que han fallado:</p> <p></p> <p>A continuaci\u00f3n se pide el denegar acceso a solo cierta parte de la p\u00e1gina, pero como nuestras webs es\u00e1n faltas del mencionado <code>contact.html</code>, he escrito c\u00f3mo se ver\u00eda si quisi\u00e9semos denegar acceso al mismo incluso si en mi p\u00e1gina no hace nada:</p> <p></p>"},{"location":"actividad_2.2/#combinacion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP","text":"<p>Tambi\u00e9n podemos usar las restricciones para denegar el acceso a partir de las IP. con la ayuda de <code>allow</code> y <code>deny</code>. Y se pueden perfectamente combinar las IP con la necesidad de identificaci\u00f3n de usuario.</p> <p>En la Tarea 1 de esta secci\u00f3n se ped\u00eda denegar el acceso a la IP de nuestra m\u00e1quina anfitriona:</p> <p></p> <p>Y si comprobamos tras guardar y reiniciar, deber\u00eda darnos otro error:</p> <p></p> <p>El cu\u00e1l tambi\u00e9n podemos comprobar a trav\u00e9s del <code>error.log</code>:</p> <p></p> <p>Como se mencion\u00f3 anteriormente, tambi\u00e9n se puede configurar para que se necesite acceso desde cierta IP o con la autentificaci\u00f3n de usuario, y lo podemos hacer as\u00ed:</p> <p></p> <p>Al probar entrar a la p\u00e1gina desde mi m\u00e1quina, se comprueba que esta vez me deja entrar, por darme derecho a la IP de que puedo acceder:</p> <p></p>"},{"location":"actividad_2.2/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.2/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, equivoc\u00e1ndome al poner el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n    deny  all;\n    auth_basic \"Cuesti\u00f3n final 1\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: Supuestamente no deber\u00eda dejar entrar, ya que pide tanto la IP como el usuario correcto.</p>"},{"location":"actividad_2.2/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  all;\n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 2: The revenge\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: Esta vez se puede acceder, porque esa IP en concreto tiene el permiso para entrar Y el usuario se ha introducido bien, incluso con el <code>deny all</code> de por medio.</p>"},{"location":"actividad_2.2/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;    \n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: No podr\u00edamos acceder desde esa IP porque est\u00e1 denegada. Esa prohibici\u00f3n tiene prioridad sobre el <code>satisfy any</code>.</p>"},{"location":"actividad_2.2/#cuestion-4","title":"Cuesti\u00f3n 4","text":"<p>A lo mejor no sab\u00e9is que tengo una web para documentar todas mis excursiones espaciales con Jeff, es esta: Jeff Bezos y yo.</p> <p>Supongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n b\u00e1sica a la URL:<code>Proyectos</code></p> <p>Completa la configuraci\u00f3n para conseguirlo:</p> <p>Ejemplo sin el c\u00f3digo</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre> <p>C\u00f3digo modificado</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n        location /Proyectos {\n                auth_basic \"\u00c1rea restringida\";\n                auth_basic_user_file /etc/nginx/.htpasswd;\n                try_files $uri $uri/ =404;\n        }\n    }\n</code></pre>"},{"location":"actividad_2.3/","title":"Practica 2.3","text":""},{"location":"actividad_2.3/#proxy-inverso-con-nginx","title":"Proxy inverso con Nginx","text":""},{"location":"actividad_2.3/#configuraciones","title":"Configuraciones","text":"<p>Nginx servidor web</p> <p>Vamos a clonar nuestra primera m\u00e1quina de Debian para poder tener dos, siguiendo estas pautas:</p> <ul> <li>Uno servir\u00e1 para la web que ya hemos montado en la pr\u00e1ctica anterior (Actividad 2.1).</li> <li>La nueva m\u00e1quina clonada se usar\u00e1 para el proxy inverso.</li> <li>Realizaremos las peticiones HTTP desde el navegador de nuestra m\u00e1quina f\u00edsica/anfitri\u00f3n al proxy clonado, que luego redirigir\u00e1 al servidor web original.</li> </ul> <pre><code>\u00a1OJO! Al clonar las m\u00e1quinas virtuales porque hay que darle a crear una nueva MAC, de lo contrario no tendr\u00e9is IP en esa m\u00e1quina.\n</code></pre> <p></p> <p></p> <p>Para diferenciarlo mejor, vamos a modificar los servidores para que cada uno haga la petici\u00f3n desde un puerto diferente.</p> <ol> <li> <p>Primero, vamos a cambiar el nombre antiguo del servidor web original por el de <code>webserver</code>, y eso implica:</p> </li> <li> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles para Nginx.</p> </li> <li> <p>Cambiar el nombre del sitio web dentro de este archivo de configuraci\u00f3n donde haga falta.</p> </li> </ol> <p></p> <ul> <li>No os olvid\u00e9is de eliminar el link simb\u00f3lico antiguo con el comando <code>unlink nombre_del_link</code> dentro de la carpeta <code>sites-enabled</code> y crear el nuevo para el nuevo nombre de archivo.</li> </ul> <p></p> <p></p> <p></p> <ol> <li>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que el servidor escuche en el puerto 80, cambiadlo al 8080.</li> </ol> <p></p> <ol> <li>Reiniciamos Nginx.</li> </ol> <p></p> <p>Nginx proxy inverso</p> <p>Ahora, cuando intentamos acceder a <code>http://ejemplo-proxy</code> (o el nombre que tuvier\u00e1is de vuestra web de las pr\u00e1cticas anteriores), en realidad estaremos accediendo al proxy, que nos redirigir\u00e1 a <code>http://webserver:8080</code>, el servidor web que acabamos de configurar para que escuche con ese nombre en el puerto 8080. Pero para ello debemos seguir los siguientes pasos:</p> <ul> <li> <p>Crear un archivo de configuraci\u00f3n en sites-available con el nombre ejemplo-proxy (o el que tuvier\u00e1is vosotros).</p> </li> <li> <p>Este archivo de configuraci\u00f3n ser\u00e1 m\u00e1s simple, tendr\u00e1 la siguiente forma.</p> </li> </ul> <pre><code>server { \n    listen __; \n    server_name ____________; \n    location / { \n    proxy_pass http://_________:____; \n    } \n} \n</code></pre> <p>Donde, mirando el diagrama de red y teniendo en cuenta la configuraci\u00f3n hecha hasta ahora, deb\u00e9is completar:</p> <ul> <li> <p>El puerto donde est\u00e1 escuchando el proxy inverso</p> </li> <li> <p>El nombre de vuestro dominio o sitio web original al que accedemos en el proxy</p> </li> <li> <p>La directiva <code>proxy_pass</code> indica a d\u00f3nde se van a redirigir las peticiones, esto es, al servidor web. Por tanto, deb\u00e9is poner la IP y n\u00famero de puerto adecuados de vuestro sitio web configurado en el apartado anterior.</p> </li> <li> <p>Crear el link simb\u00f3lico pertinente</p> </li> </ul> <p></p> <p></p> <p>\u00a1OJO! En mi caso en concreto he tenido que poner el link en el <code>proxy_pass</code> sin el <code>8080</code> al final, de otra manera no me llegaba a funcionar.</p> <pre><code>Deb\u00e9is modificar el archivo host que configurast\u00e9is en la pr\u00e1ctica 2.1. Si mir\u00e1is el diagrama de red, ahora el nombre de vuestro sitio web se corresponder\u00e1 con la IP de la nueva m\u00e1quina clon que hace de proxy. Ser\u00e1 \u00e9sta la encargada de redirigirnos autom\u00e1ticamente al verdadero sitio web.\n</code></pre> <p></p>"},{"location":"actividad_2.3/#comprobaciones","title":"Comprobaciones","text":"<p>Deber\u00edais poder acceder a vuestro sitio web sin problemas.</p> <ul> <li> <p>Comprobad en los access.log de los dos servidores que llega la petici\u00f3n</p> </li> <li> <p>Comprobad adem\u00e1s la petici\u00f3n y respuesta con las herramientas de desarrollador de Firefox en Xubuntu. Pulsando F12 en el navegador os aparecer\u00e1n estas herramientas.</p> </li> </ul> <p></p> <p></p> <p>Deb\u00e9is entrar en Red &gt; luego donde se puede ver la respuesta &gt; y ver la respuesta HTTP como petici\u00f3n GET HTTP (200 OK).</p> <p>Tambi\u00e9n deber\u00edan aparecer las cabeceras, de las cuales podemos a\u00f1adir algunas nosotros.</p> <p>A\u00f1adiendo cabeceras</p> <pre><code>Es importante desactivar el cach\u00e9 para hacer las pruebas siguientes.\n</code></pre> <p>Como una manera extra de comprobar que todo va bien, podemos a\u00f1adir las cabeceras de la siguiente manera:</p> <ul> <li>Para a\u00f1adir cabeceras, en el archivo de configuraci\u00f3n del sitio web debemos a\u00f1adir dentro del bloque <code>location / { \u2026 }</code> debemos a\u00f1adir la directiva: </li> </ul> <pre><code>add_header Host nombre_del_host;\n</code></pre> <ol> <li>A\u00f1adimos primero esta cabecera solo en el archivo de configuraci\u00f3n del proxy inverso. El Nombre_del_host ser\u00e1 Proxy_inverso_vuestronombre.</li> </ol> <p></p> <ol> <li> <p>Reiniciamos Nginx.</p> </li> <li> <p>Comprobamos que podemos acceder al sitio web sin problemas.</p> </li> <li> <p>Con las herramientas de desarrollador comprobamos que el nuevo header aparece en la respuesta.</p> </li> <li> <p>Luego hacemos lo mismo pero con el archivo del servidor web original. Esta vez el <code>Nombre_del_host</code> ser\u00e1 <code>servidor_web_vuestronombre</code>.</p> </li> </ol> <p>Si todo est\u00e1 bien, ahora deber\u00edan aparecer los dos.</p> <p></p>"},{"location":"actividad_2.4/","title":"Practica 2.4","text":""},{"location":"actividad_2.4/#balanceo-de-carga-con-proxy-inverso-en-nginx","title":"Balanceo de carga con proxy inverso en Nginx","text":""},{"location":"actividad_2.4/#configuraciones","title":"Configuraciones","text":"<pre><code>\u00a1OJO! Como detalle a tener en cuenta, deberemos desactivar los sitios web de las tareas anteriores para que no den problemas.\n\nDentro de la carpeta `/etc/nginx/sites-enabled` debemos ejecutar `unlink nombre_archivo` para cada uno de los archivos de los sitios web que tenemos.\n</code></pre>"},{"location":"actividad_2.4/#nginx-servidor-web-1","title":"Nginx Servidor Web 1","text":"<p>Debemos configurar este servidor web para que sirva el siguiente <code>index.html</code> que deb\u00e9is crear dentro de la carpeta <code>/var/www/webserver1/html</code>:</p> <p></p> <ul> <li> <p>El nombre del sitio web que se debe utilizar en los archivos (sites-available, etc) para Nginx es <code>webserver1</code>, igual que en el resto de configuraciones.</p> </li> <li> <p>El sitio web debe escuchar al puerto 8080.</p> </li> <li> <p>Se debe a\u00f1adir una cabecera que se llame <code>Serv_Web1_vuestronombre</code>.</p> </li> </ul> <p></p>"},{"location":"actividad_2.4/#nginx-servidor-web-2","title":"Nginx Servidor Web 2","text":"<p>Se debe clonar en la m\u00e1quina Debian, del servidor web 1.</p> <p></p> <p>Se debe hacer una configuraci\u00f3n id\u00e9ntica, pero cambiando los nombres de <code>webserver1</code> por <code>webserver2</code> (inclu\u00eddo el index.html), y el nombre de la cabecera ser\u00e1 <code>Serv_Web2_vuestronombre</code>.</p> <pre><code>\u00a1OJO! Es importante que no quede ninguna referencia al webserver1, o podr\u00eda haber problemas.\n</code></pre>"},{"location":"actividad_2.4/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>Ya que tenemos los servidores web, lo que nos quedar\u00e1 es configurar el proxy inverso.</p> <ul> <li>En sites-available vamos a crear el archivo de configuraci\u00f3n con el nombre <code>balanceo</code>.</li> </ul> <p>Y el archivo tendr\u00e1 el siguiente formato:</p> <pre><code>    upstream backend_hosts {\n                random;\n                server ________:____;\n                server ________:____;\n    }\n            server {\n                listen 80;\n                server_name ________;      \n                location / {\n                    proxy_pass http://backend_hosts;\n                }\n            }\n</code></pre> <ul> <li> <p>El bloque upstream \u2192 son los servidores entre los que se va a repartir la carga, que son los dos que hemos configurado anteriormente.</p> </li> <li> <p>Si mir\u00e1is el diagrama y ten\u00e9is en cuenta la configuraci\u00f3n que hab\u00e9is hecho hasta ahora, aqu\u00ed deber\u00e9is colocar la IP de cada servidor, as\u00ed como el puerto donde est\u00e1 escuchando las peticiones web.</p> </li> <li> <p>A este grupo de servidores le ponemos un nombre, que es <code>backend_hosts</code>.</p> </li> <li> <p>Pondremos random porque es lo m\u00e1s f\u00e1cil para comprobar que todo funciona bien en la pr\u00e1ctica, pero hay diferentes formas de repartir la carga (las peticiones HTTP). </p> </li> </ul> <p></p>"},{"location":"actividad_2.4/#comprobaciones","title":"Comprobaciones","text":"<p>Se deber\u00eda poder acceder al sitio web sin problemas, recordando que se debe desactivar el cach\u00e9.</p> <p></p> <p></p> <p>Si refrescamos, el servidor es aleatorio, y si se desactiva el servidor 1, se ir\u00e1 al 2, igual que si desactivamos el servidor 2, se ir\u00e1 al 1.</p>"},{"location":"actividad_2.4/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.4/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Busca informaci\u00f3n de qu\u00e9 otros m\u00e9todos de balanceo se pueden aplicar con Nginx y describe al menos 3 de ellos.</p> <ul> <li> <p><code>Round Robin</code>: Asigna las solicitudes en un ciclo uniforme entre todos los servidores, ideal para ambientes de carga similar\u200b.</p> </li> <li> <p><code>Least Connections</code>: Redirige las solicitudes al servidor con menos conexiones activas, equilibrando cargas en sistemas con tr\u00e1fico variable.</p> </li> <li> <p><code>IP Hash</code>: Env\u00eda solicitudes del mismo cliente al mismo servidor, manteniendo la sesi\u00f3n y datos consistentes, \u00fatil para aplicaciones como e-commerce.</p> </li> </ul>"},{"location":"actividad_2.4/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Si quiero a\u00f1adir 2 servidores web m\u00e1s al balanceo de carga, describe detalladamente qu\u00e9 configuraci\u00f3n habr\u00eda que a\u00f1adir y d\u00f3nde.</p> <ul> <li>Si tenemos ya configurado, lo \u00fanico que debemos hacer es a\u00f1adir los servidores extra en el bloque de <code>upstream</code>.</li> </ul> <pre><code>upstream webserverejemplo {\n    ...;\n    server &lt;host_servidor_1&gt;:&lt;puerto_servidor_1&gt;;\n    server &lt;host_servidor_2&gt;:&lt;puerto_servidor_2&gt;;\n}\n</code></pre>"},{"location":"actividad_2.4/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Describe todos los pasos que deber\u00edamos seguir y configurar para realizar el balanceo de carga con una de las webs de pr\u00e1cticas anteriores.</p> <p>Indicad la configuraci\u00f3n de todas las m\u00e1quinas (webservers, proxy...) y de sus servicios.</p> <ul> <li> <p>Tal y como hemos hecho con este ejercicio, se deber\u00e1n tener al menos 3 m\u00e1quinas virtuales. El servidor web original, el servidor 2 clonado del original, y el proxy inverso.</p> </li> <li> <p>Para la configuraci\u00f3n del servidor web, debemos crear un archivo en el directorio <code>/etc/nginx/sites-available</code>, y debemos elegir un nombre. Para este ejemplo, se llamar\u00e1 <code>webtest</code> y debe quedar as\u00ed:</p> </li> </ul> <pre><code>/etc/nginx/sites-available/webtest\n\nserver {\n    listen 8080;\n    server_name webtest.local;\n\n    location / {\n        root /var/www/webtest/html;\n        index index.html;\n\n        add_header webtest_lara webtest;\n    }\n}\n</code></pre> <ul> <li>Tras tener configurado el archivo, creamos el enlace:</li> </ul> <pre><code>sudo ln -s /etc/nginx/sites-available/webtest /etc/nginx/sites-enabled/\n</code></pre> <ul> <li>Y lo reiniciamos:</li> </ul> <pre><code>sudo systemctl restart nginx\n</code></pre> <ul> <li>Para la configuraci\u00f3n del servidor clonado, solo se tiene que clonar el servidor anterior, pero cambiando el antiguo <code>server_name</code> para que no haya errores.</li> </ul> <pre><code>/etc/nginx/sites-available/webtest\n\nserver {\n    listen 8080;\n    server_name webtest2.local;\n\n    location / {\n        root /var/www/webtest/html;\n        index index.html;\n\n        add_header webtest2_lara webtest;\n    }\n}\n</code></pre> <ul> <li>Para la configuraci\u00f3n del proxy, lo haremos igual que en la pr\u00e1ctica en s\u00ed. Creamos un archivo que deber\u00eda llevar esta configuraci\u00f3n:</li> </ul> <pre><code>/etc/nginx/sites-available/webtest-proxy\n\n    upstream webtest {\n                random;\n                server webtest.local:8080;\n                server webtest2.local:8080;\n    }\n            server {\n                listen 80;\n                server_name webtest.local;      \n                location / {\n                    proxy_pass http://webtest;\n                }\n            }\n</code></pre> <ul> <li>No se debe olvidar el crear los enlaces pertinentes con el comando de siempre:</li> </ul> <pre><code>sudo ln -s /etc/nginx/sites-available/webtest-proxy /etc/nginx/sites-enabled/\n</code></pre> <ul> <li>Por \u00faltimo, se reinicia de nuevo:</li> </ul> <pre><code>sudo systemctl restart nginx\n</code></pre> <ul> <li>Como \u00faltimo paso, a\u00f1adimos al archivo hosts de nuestro pc la IP del proxy para poder probarlo, en Windows, la localizaci\u00f3n ser\u00eda:</li> </ul> <pre><code>C:\\Windows\\System32\\drivers\\etc\\hosts\n\n...\nip-proxy webtest.local\n</code></pre> <ul> <li>En Linux, la localizaci\u00f3n estar\u00eda en:</li> </ul> <pre><code>/etc/hosts\n\n...\nip-proxy webtest.local\n</code></pre>"},{"location":"actividad_2.5/","title":"Practica 2.5","text":""},{"location":"actividad_2.5/#proxy-inverso-y-balanceo-de-carga-con-ssl-en-nginx","title":"Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"actividad_2.5/#configuraciones","title":"Configuraciones","text":"<p>Partiendo de la configuraci\u00f3n exacta de la pr\u00e1ctica anterior, vamos a a\u00f1adir la configuraci\u00f3n SSL para el cifrado del Proxy Inverso.</p>"},{"location":"actividad_2.5/#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado","text":"<p>Nosotros no usaremos un CA de confianza, ya que no estamos publicando en internet Y los certificados son de pago.</p> <p>Nosotros crearemos el nuestro propio para simular el escenario, por lo que la primera vez que accedamos el sitio web, saldr\u00e1 una advertencia.</p> <p>En primer lugar, tenemos que crear el sguiente directorio:</p> <p><code>/etc/nginx/ssl</code></p> <p></p> <p>Luego, podemos crear el certificado con un \u00fanico comando:</p> <p><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/server.key -out /etc/nginx/ssl/server.crt</code></p> <p></p> <p>Nos preguntar\u00e1 el introducir una serie de par\u00e1metros. Se deben introducir los par\u00e1metros de la siguiente imagen, a excepci\u00f3n del \u201cOrganizational Unit Name\u201d. Ah\u00ed deber\u00e9is poner <code>2DAW \u2013 DEAW - Vuestronombre</code>.</p> <p></p>"},{"location":"actividad_2.5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el proxy inverso","text":"<p>De la pr\u00e1ctica anterior, ya deber\u00edas tener en el directorio <code>/etc/nginx/sites-available</code> un archivo de configuraci\u00f3n llamado \u201cbalanceo\u201d. Aqu\u00ed es donde vamos a configurar el acceso al sitio web para que funcione con SSL (HTTPS).</p> <p>Dentro del bloque <code>server {\u2026}</code>, cambia el puerto de escucha (<code>listen 80</code>) por lo que ves en la imagen de abajo. Adem\u00e1s, a\u00f1ade las siguientes l\u00edneas de configuraci\u00f3n para que quede as\u00ed:</p> <p></p> <p>Recordad el reiniciar el servicio de Nginx como de costumbre tras el cambio.</p>"},{"location":"actividad_2.5/#comprobaciones","title":"Comprobaciones","text":"<ul> <li> <p>Si ahora accedes a <code>https://balanceo.local</code>, ver\u00e1s un aviso de seguridad porque nuestro certificado es autofirmado, como mencionamos antes.</p> </li> <li> <p>Si agregas una excepci\u00f3n, podr\u00e1s entrar al sitio, y al recargar la p\u00e1gina varias veces con F5, ver\u00e1s que el balanceo de carga funciona bien usando HTTPS.</p> </li> <li> <p>Para confirmar que los datos del certificado son los tuyos, haz clic en el candado en la barra de b\u00fasqueda:</p> </li> </ul> <p></p> <p></p> <p></p>"},{"location":"actividad_2.5/#redireccion-forzosa-a-https","title":"Redirecci\u00f3n forzosa a HTTPS","text":"<p>Para que s\u00ed o s\u00ed nos fuerce a usar HTTPS, haremos una configuraci\u00f3n adicional.</p> <p>A\u00f1adiremos un nuevo bloque 'server' separado del otro, en el archivo de configuraci\u00f3n de 'balanceo'.</p> <p>Debe quedar algo as\u00ed:</p> <p></p> <p>Lo que estamos haciendo es que cuando se reciba una petici\u00f3n HTTP (puerto 80) en <code>http://balanceo.local</code>, se redirija a <code>https://balanceo.local</code> (HTTPS).</p> <p>La tarea extra ha consistido en:</p> <ul> <li> <p>Eliminar del otro bloque <code>server{...}</code> las l\u00edneas que hac\u00edan referencia al puerto 80.</p> </li> <li> <p>Hemos reiniciado el servicio.</p> </li> <li> <p>Se ha comprobado que ahora fuerza siempre la redirecci\u00f3n a HTTPS.</p> </li> <li> <p>Y se ha comprobado que cuando realizamos una petici\u00f3n en el archivo de log <code>http_access.log</code> aparece la redirecci\u00f3n 301 y que, de la misma manera, aparece una petici\u00f3n GET en <code>https_access.log</code>.</p> </li> </ul> <p></p>"},{"location":"actividad_2.5/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.5/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error del tipo <code>This site can't provide a secure connection, ERR_SSL_PROTOCOL_ERROR</code>.</p> <p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\n    listen 443;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n</code></pre> <p>En el primer <code>listen 443</code> ha faltado poner el <code>ssl</code>. Deber\u00eda quedar como:</p> <p><code>listen 443 ssl;</code></p>"},{"location":"actividad_2.5/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Imaginad que intentamos acceder a nuestro sitio web HTTPS y nos encontramos con el siguiente error, luego, investigad qu\u00e9 est\u00e1 pasando y como se ha de solucionar.</p> <p></p> <p>El error <code>NET::ERR_CERT_REVOKED</code> en una conexi\u00f3n HTTPS significa que el certificado del sitio ha sido revocado por la entidad certificadora, lo que indica que ya no es confiable. Esto puede suceder si el certificado fue comprometido, emitido por error, o revocado a petici\u00f3n del propietario. Para solucionarlo, el administrador del sitio debe reemplazar el certificado por uno nuevo y v\u00e1lido; como usuario, no puedes evitar el error hasta que el sitio lo corrija.</p>"},{"location":"actividad_3.1/","title":"Practica 3.1 Instalaci\u00f3n de Tomcat","text":""},{"location":"actividad_3.1/#instalacion-de-tomcat","title":"Instalaci\u00f3n de Tomcat","text":"<p>Realizaremos la instalaci\u00f3n del servidor de aplicaciones Tomcat 10, en una m\u00e1quina virtual corriendo Debian 11 Bullseye.</p> <p>En mi caso, he seguido el siguiente tutorial para instalarlo con el administrador de paquetes.</p>"},{"location":"actividad_3.1/#despliegue-manual-mediante-la-gui-de-administracion","title":"Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Para esta pr\u00e1ctica podemos descargar el WAR aqu\u00ed.</p> <p>Realizaremos el despliegue manual de una aplicaci\u00f3n ya previamente empaquetada en formato WAR. Para ello:</p> <ul> <li> <p>Nos logueamos con el usuario previamente creado.</p> </li> <li> <p>Buscamos la secci\u00f3n que nos permite desplegar un WAR manualmente, seleccionamos nuestro archivo y lo desplegamos.</p> </li> </ul> <p></p> <p></p>"},{"location":"actividad_3.1/#despliegue-con-maven","title":"Despliegue con Maven","text":""},{"location":"actividad_3.1/#instalacion-de-maven","title":"Instalaci\u00f3n de Maven","text":"<p>Hay dos maneras de instalarlo, con el administrador de paquetes o manualmente. Yo personalmente voy a explicar c\u00f3mo instalarlo con el administrador de paquetes siguiendo estos sencillos pasos:</p> <p>Actualizamos los repositorios:</p> <pre><code>sudo apt update\n</code></pre> <p>Instalamos Maven:</p> <pre><code>sudo apt install maven\n</code></pre> <p>Comprobamos que funciona bien:</p> <pre><code>mvn --v\n</code></pre> <p></p>"},{"location":"actividad_3.1/#configuracion-de-maven","title":"Configuraci\u00f3n de Maven","text":"<p>Necesitamos realizar la configuraci\u00f3n adecuada para Maven, modificando los siguientes archivos:</p> <p>Modificamos el archivo <code>/etc/tomcat9/tomcat-users.xml</code> acorde a nuestras necesidades (los nombres de usuario y contrase\u00f1a deber\u00e1n ser los que elij\u00e1is para vosotros), debe quedar as\u00ed:</p> <p></p> <p>Luego, editamos el archivo <code>/etc/maven/settings.xml</code> para indicarle a Maven, un identificador para el servidor sobre el que vamos a desplegar (no es m\u00e1s que un nombre, ponedle el nombre que consider\u00e9is), as\u00ed como las credenciales. Todo esto se har\u00e1 dentro del bloque servers del XML:</p> <p></p>"},{"location":"actividad_3.1/#configurar-un-proyecto-de-java-maven","title":"Configurar un proyecto de Java Maven","text":"<p>Como para este paso necesitamos un proyecto de Java que utilice Maven, usaremos un repositorio para la pr\u00e1ctica y pondremos el patch-1 para cubrir de paso una tarea que se preguntaba m\u00e1s delante:</p> <pre><code>git clone https://github.com/cameronmcnz/rock-paper-scissors.git &amp;&amp; cd rock-paper-scissors &amp;&amp; git checkout patch-1\n</code></pre> <p>Despues de hacerlo, debemos modificar el <code>POM</code> del proyecto para que haga referencia a que el despliegue se realice con el plugin de Maven para Tomcat.</p> <p></p> <p>Este es el bloque a a\u00f1adir:</p> <pre><code>&lt;build&gt;\n        &lt;finalName&gt;war-deploy&lt;/finalName&gt; \n\n\n        &lt;plugins&gt; \n        &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; \n\n\n            &lt;server&gt;Tomcat.P.3.1&lt;/server&gt; \n\n\n            &lt;path&gt;/myapp&lt;/path&gt; \n\n\n        &lt;/configuration&gt;\n        &lt;/plugin&gt;\n        &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>"},{"location":"actividad_3.1/#despliegue","title":"Despliegue","text":"<p>Teniendo ya todo listo para realizar despliegues, ahora crearemos una aplicaci\u00f3n Java de prueba para ver si podemos desplegarla sobre la arquitectura que hemos montado. Para ello utilizamos el comando:</p> <pre><code>mvn archetype:generate -DgroupId=lara -DartifactId=war-deploy -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false\n</code></pre> <p>Tras generar esta aplicaci\u00f3n, usaremos un comando final para desplegar y comprobar que se ha buildeado correctamente:</p> <pre><code>sudo mvn tomcat7:deploy\n</code></pre> <p></p> <p>Y, accediendo a trav\u00e9s de la GUI, debemos ver que la aplicaci\u00f3n est\u00e1 desplegado y que podemos acceder a ella perfectamente:</p> <p></p> <p></p>"},{"location":"actividad_3.1/#cuestiones","title":"Cuestiones","text":"<pre><code>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas.\n\nEn principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averig\u00fcar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?\n</code></pre> <p>Se espera que, al instalar Tomcat, solo root y el usuario que lo ejecuta puedan acceder a esos archivos, para proteger las contrase\u00f1as, igual que pasa con el archivo /etc/shadow, que solo los administradores pueden ver.</p>"},{"location":"actividad_3.2/","title":"Practica 3.2 Despliegue de aplicaciones con Node Express","text":""},{"location":"actividad_3.2/#ojo","title":"\u00a1OJO!","text":"<p>Debemos comprobar que el servidor de Tomcat que hemos instalado anteriormente est\u00e1 desactivado, o dar\u00e1 problemas:</p> <p><code>sudo systemctl status tomcat10</code></p> <p>Y en caso de que est\u00e9 activo, se para:</p> <p><code>sudo systemctl stop tomcat10</code></p>"},{"location":"actividad_3.2/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Primero, instalaremos Node.js y Express en Debian 11. Luego, crearemos un archivo <code>.js</code> de prueba para asegurarnos de que el despliegue funciona.</p> <p>Personalmente he seguido este [tutorial] (https://web.archive.org/web/20240420163631/https://unixcop.com/how-to-install-expressjs-on-debian-11/) para instalar Node.js.</p> <p>Para Express, recuerda acceder a <code>http://IP-maq-virtual:3000</code> desde tu m\u00e1quina local, usando la IP de tu m\u00e1quina virtual, en lugar de <code>http://localhost:3000</code>.</p> <p>Recordad parar el servidor (CTRL+C) al acabar la pr\u00e1ctica.</p> <p> </p>"},{"location":"actividad_3.2/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Vamos a desplegar una app de terceros como ejemplo. Es un prototipo de predicci\u00f3n meteorol\u00f3gica que est\u00e1 en este repositorio de GitHub.</p> <p>Lo primero es clonar el repositorio siguiendo las instrucciones que ah\u00ed se indican:</p> <pre><code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application\n</code></pre> <p>Nos movemos al nuevo directorio:</p> <pre><code>cd Shopping-Cart-Application/\n</code></pre> <p></p> <p>Instalamos librer\u00edas necesarias:</p> <pre><code>npm install\n</code></pre> <p>Y por \u00faltimo la iniciamos:</p> <pre><code>npm run start\n</code></pre> <p>Dar\u00e1 un error de este tipo al intentar arrancar:</p> <pre><code>sh: 1: nodemon: not found\n</code></pre> <p></p> <p>Para solucionar el problema, instalamos nodemon desde consola y listo.</p> <p> </p>"},{"location":"actividad_3.2/#cuestiones","title":"Cuestiones","text":"<p>Cuando ejecut\u00e1is el comando npm run start, lo que est\u00e1is haciendo es ejecutar un script:</p> <pre><code>- \u00bfDonde podemos ver que script se est\u00e1 ejecutando?\n</code></pre> <p>En el archivo <code>package.json</code>, dentro de la secci\u00f3n <code>\"scripts\"</code>. Ah\u00ed se define qu\u00e9 hace el comando <code>npm run start</code>.</p> <pre><code>- \u00bfQu\u00e9 comando est\u00e1 ejecutando?\n</code></pre> <p>Depende de lo que est\u00e9 configurado en <code>\"start\"</code> en el <code>package.json</code>. Por ejemplo, podr\u00eda ser algo como node <code>server.js</code>, <code>nodemon app.js</code>, o cualquier otro comando que se especifique en esa l\u00ednea.</p>"},{"location":"actividad_3.3/","title":"Practica 3.3 Despliegue de una aplicaci\u00f3n una aplicaci\u00f3n React en Netlify (PaaS)","text":""},{"location":"actividad_3.3/#creacion-de-nuestra-aplicacion","title":"Creaci\u00f3n de nuestra aplicaci\u00f3n","text":"<p>Despu\u00e9s de iniciar sesi\u00f3n por SSH en nuestro Debian, creamos una carpeta para la aplicaci\u00f3n con el nombre que prefiramos. Dentro de esa carpeta, a\u00f1adimos los 3 archivos necesarios: dos <code>.html</code> y un <code>.js</code> para nuestra sencilla app de ejemplo.</p> <p>El directorio se puede crear con el comando <code>mkdir</code> como hemos hecho otras veces, mientras que los archivos en cuestion se pueden crear usando el comando <code>sudo nano head.html</code> por ejemplo.</p> <p>head.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n        &lt;h1&gt;Esta es la pagina principal&lt;/h1&gt;\n\n&lt;p&gt;&lt;a href=\"/tailPage\"&gt;Ir a la siguiente pagina&lt;/a&gt;&lt;/p&gt;\n\n\n&lt;/body&gt;\n</code></pre> <p></p> <p>tail.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;h1&gt;FUNCIONA&lt;/h1&gt;\n\n&lt;/body&gt;\n</code></pre> <p></p> <p>aplicacion.js</p> <pre><code>var http = require('http');\nvar fs = require('fs'); // para obtener los datos del archivo html\nvar port = process.env.PORT || 8080; \n\nhttp.createServer(function (req, res) {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n\n    // req.url almacena el path o ruta de la URL\n    var url = req.url;\n    if (url === \"/\") {\n// fs.readFile busca el archivo HTML\n// el primer par\u00e1metro es el path al archivo HTML\n// y el segundo es el callback de la funci\u00f3n\n// si el archivo no se encuentra, la funci\u00f3n devuelve un error\n// si el archivo se encuentra, el contenido del mismo se encuentra en pgres    \n        fs.readFile(\"head.html\", function (err, pgres) {\n            if (err)\n                res.write(\"HEAD.HTML NOT FOUND\");\n            else {\n                // Las siguientes 3 lineas\n                // tienen la funci\u00f3n de enviar el archivo html\n                // y finalizar el proceso de respuesta\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n    else if (url === \"/tailPage\") {\n        fs.readFile(\"tail.html\", function (err, pgres) {\n            if (err)\n                res.write(\"TAIL.HTML NOT FOUND\");\n            else {\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n\n}).listen(port, function () {\n    console.log(\"SERVER STARTED PORT: 8080\");\n});\n</code></pre> <p></p> <p>A continuaci\u00f3n, creamos el archivo <code>package.json</code> con el siguiente comando:</p> <p><code>npm init</code></p> <p></p> <p>Y podemos probar si funciona:</p> <p><code>node aplicacion.js</code></p> <p>Tras hacer eso, deber\u00edamos poder acceder con nuestra m\u00e1quina anfitriona a <code>http://IP-maq-virtual:8080</code></p> <p> </p>"},{"location":"actividad_3.3/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Utilizaremos una aplicaci\u00f3n de ejemplo para esta pr\u00e1ctica.</p> <p>Simplemente, clonaremos el siguiente repositorio con el comando:</p> <p><code>git clone https://github.com/StackAbuse/color-shades-generator</code></p> <p></p>"},{"location":"actividad_3.3/#proceso-de-despliegue-en-netlify","title":"Proceso de despliegue en Netlify","text":"<p>Veremos dos m\u00e9todos de despliegue en Netlify, el primero ser\u00e1 el despliegue manual desde el CLI de Netlify, y el otro ser\u00e1 con conexi\u00f3n a un c\u00f3digo publicado en Github.</p> <p>Tened en cuenta que deb\u00e9is haceros una cuenta en Netlify.</p>"},{"location":"actividad_3.3/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Una vez estemos registrados, instalamos el CLI de Netlify:</p> <p><code>sudo npm install netlify-cli -g</code></p> <p></p> <p>Pedir\u00e1 autentificaci\u00f3n, lo haremos con el comando:</p> <p><code>netlify login</code></p> <p>Como estamos conectados por SSH, podemos generar un token desde Netlify, y lo establecemos como variable de ambiente:</p> <p></p> <p></p> <p>Y ya podremos logearnos con</p> <p><code>netlify login</code></p> <p>Como buenos desarrolladores, haremos un build de la aplicaci\u00f3n para antes de desplegarla.</p> <p>Primero debemos instalar las dependencias indicadas en el archivo <code>package.json</code>:</p> <p><code>npm install</code></p> <p></p> <p>Y cuando lo tengamos procedemos al build:</p> <p><code>npm run build</code></p> <p></p> <p>Esto nos crea la carptea <code>build</code> que contendr\u00e1 la aplicaci\u00f3n a desplegar.</p> <p>Haremos un pre-deploy de la app con el siguiente comando:</p> <p><code>netlify deploy</code></p> <p></p> <p>Nos har\u00e1 unas cuantas preguntas para el despliegue:</p> <ul> <li> <p>Indicamos que queremos crear y configurar una nueva site.</p> </li> <li> <p>El Team se deja por defecto.</p> </li> <li> <p>El nombre para la web ser\u00e1 <code>nombre-practica3-4</code> y el directorio que utilizaremos ser\u00e1 <code>./build</code>.</p> </li> </ul> <p>Si nos indica que todo ha ido bien e incluso podemos ver el \"borrador\" (Website Draft URL) de la web que nos aporta, podemos pasarla a producci\u00f3n finalmente tal y como nos indica la misma salida del comando:</p> <pre><code>If everything looks good on your draft URL, deploy it to your main site URL with the --prod flag.\nnetlify deploy --prod\n</code></pre> <p></p> <p>No olvideis desplegar finalmente para poder comprobar que se puede acceder a la URL:</p> <p></p>"},{"location":"actividad_3.3/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>primero eliminamos la site que hemos desplegado en Netlify para evitar conflictos:</p> <p></p> <p>Luego borramos el directorio donde hemos clonado el repositorio para empezar de 0:</p> <p><code>rm -rf directorio_repositorio</code></p> <p>A continuaci\u00f3n, descargamos un <code>.zip</code> sin que tenga referencia a Github:</p> <p><code>wget https://github.com/StackAbuse/color-shades-generator/archive/refs/heads/main.zip</code></p> <p></p> <p>Y creamos la carpeta nueva para descomprimir el .zip all\u00ed:</p> <pre><code>mkdir practica3.4\n\nunzip main.zip -d practica3.4/\n</code></pre> <p></p> <p>Ya podemos entrar en la carptea donde est\u00e1 el c\u00f3digo:</p> <p><code>cd practica3.4/color-shades-generator-main/</code></p> <p>Ahora deberemos crear un repositorio completamente vac\u00edo en Github que se llame <code>practicaTresCuatro</code>.</p> <p>Y tras hacerlo, volvemos a la terminal para iniciar el repositorio que queremos subir:</p> <pre><code>$ git init\n$ git add .\n$ git commit -m \"Subiendo el c\u00f3digo...\"\n$ git branch -M main\n</code></pre> <p></p> <p>Y ya solo queda hacer referencia al reci\u00e9n creado Github para hacer un <code>push</code>:</p> <pre><code>$ git remote add origin https://github.com/username/practicaTresCuatro.git\n$ git push -u origin main\n</code></pre> <p></p> <p>Con el c\u00f3digo subido a Github, ahora lo que tenemos que hacer es vincular nuestra cuenta de Github con Netlify. Al hacerlo, pedir\u00e1 permisos y nosotros lo autorizaremos, pero un detalle a tener en cuenta es que cuando pregunte sobre qu\u00e9 repositorios instalar, solo elegimos el que hemos hecho para la pr\u00e1ctica.</p> <p></p> <p>Y ya lo tendremos todo listo.</p> <p></p> <p>Luego estaremos listos para desplegar la aplicaci\u00f3n.</p> <p></p> <p>Netlify se encargar\u00e1 de hacer el <code>build</code> de forma autom\u00e1tica tal y como hemos visto en la imagen de arriba, con el comando <code>npm run build</code>, publicando el contenido del directorio <code>build</code>.</p> <p>Con esta conexi\u00f3n, cualquier cambio que hagamos en el proyecto y al que le hagamos un <code>commit</code> y <code>push</code> desde Github, se actualizar\u00e1 automaticamente en Netlify.</p>"},{"location":"actividad_3.3/#comprobacion-de-que-funciona-asi","title":"Comprobaci\u00f3n de que funciona as\u00ed:","text":"<ul> <li>Dentro de la carpeta <code>public</code> existe el archivo <code>robots.txt</code>, que indica a los rastreadores de los buscadores qu\u00e9 URLs pueden acceder. Se puede acceder a trav\u00e9s de la site en s\u00ed.</li> </ul> <ul> <li>Lo que vamos a hacer es acceder la carpeta <code>public</code> donde se encuentra el archivo <code>robots.txt</code> para modificarlo, a\u00f1adiendo <code>nombre_apellido</code> en la secci\u00f3n de Disallow.</li> </ul> <ul> <li> <p>Haremos un nuevo <code>commit</code> y <code>push</code> tal y como lo hemos hecho antes.</p> </li> <li> <p>Y comprobaremos que tanto en la consola como en Netlify hay un nuevo deploy de la app.</p> </li> </ul> <p></p> <p></p> <ul> <li>Por \u00faltimo, accedemos a la url <code>https://url_de_la_aplicacion/robots.txt</code> y comprobamos que el cambio se ha reflejado.</li> </ul> <p></p>"},{"location":"actividad_3.4/","title":"Practica 3.4 Despliegue de una aplicaci\u00f3n Flask (Python)","text":""},{"location":"actividad_3.4/#procedimiento-completo-para-el-despliegue","title":"Procedimiento completo para el despliegue","text":"<p>Primero instalamos el gestor de paquetes de Python pip:</p> <p><code>sudo apt update</code></p> <p><code>sudo apt install python3-pip</code></p> <p></p> <p>Luego instalamos el paquete <code>pipenv</code> para gestionar los entornos virtuales:</p> <p><code>sudo apt install pipenv</code></p> <p></p> <p>Y comprobamos que est\u00e1 instalado correctamente mostrando su versi\u00f3n:</p> <p><code>pipenv --version</code></p> <p></p> <p>Creamos el directorio en el que almacenaremos nuestro proyecto:</p> <p><code>sudo mkdir /var/www/nombre_mi_aplicacion</code></p> <p>Cuando lo creamos con <code>sudo</code>, los permisos pertenecer\u00e1n a root, por lo que debemos cambiarlos para darle los permisos a nuestro usuario (<code>lara</code> en mi caso), y que pertenezca al grupo <code>www-data</code>, con los siguientes comandos:</p> <p><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion</code></p> <p><code>chmod -R 775 /var/www/mi_aplicacion</code></p> <p></p> <pre><code>Es indispensable que asignemos los permisos para que no haya errores.\n</code></pre> <p>A continuaci\u00f3n, dentro del directorio de nuestra aplicaci\u00f3n, creamos un archivo oculto <code>.env</code> que contendr\u00e1 las variables necesarias:</p> <p><code>touch .env</code></p> <p></p> <p>Editamos el archivo y a\u00f1adimos las variables, indicando cu\u00e1l es el archivo <code>.py</code> de la aplicaci\u00f3n y el entorno, que en nuestro caso ser\u00e1 producci\u00f3n:</p> <p></p> <p>Ahora vamos ya a iniciar nuestro entorno virtual con el siguiente comando:</p> <p><code>pipenv shell</code></p> <p>Si todo va bien, el nombre del entorno virtual debe salir antes del nombre y ruta en consola:</p> <p></p> <p>Desde dentro del entorno virtual, instalamos las dependencias necesarias para el proyecto:</p> <p><code>pipenv install flask gunicorn</code></p> <p></p> <p>El archivo que contendr\u00e1 la aplicaci\u00f3n propiamente dicha ser\u00e1 <code>application.py</code>, y <code>wsgi.py</code> se encargar\u00e1 \u00fanicamente de iniciarla y dejarla corriendo:</p> <p><code>touch application.py wsgi.py</code></p> <p>Una vez creamos los archivos, debemos editarlos para dejarlos as\u00ed:</p> <p></p> <p></p> <p>Con el servidor web integrado de Flask, vamos a correr la aplicaci\u00f3n para comprobar que todo funciona bien. Especificaremos la direcci\u00f3n 0.0.0.0:</p> <p></p> <p>Si intentamos entrar en la url, deber\u00eda funcionarnos. Recordad ponerlo de manera que <code>http://IP-maq-virtual:5000</code></p> <p></p> <p>\u00a1Y voil\u00e1! Una vez lo hemos comprobado, paramos el servidor con <code>CTRL+C</code>.</p>"},{"location":"actividad_3.4/#comprobacion-de-gunicorn","title":"Comprobaci\u00f3n de Gunicorn","text":"<p>Si Flask ha funcionado bien, usando el siguiente comando nos dir\u00e1 si Gunicorn funciona:</p> <p><code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app</code></p> <p></p> <p>Todav\u00eda en el entorno virtual, vamos a tomar nota del path desde la que se ejecuta <code>gunicorn</code>, la vamos a necesitar para m\u00e1s adelante:</p> <p></p> <p>Como ya tendr\u00edamos que tener Nginx instalado en nuestro sistema por practicas anteriores, lo iniciamos y comprobamos su estado:</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p></p> <p>Ya fuera del entorno virtual, creamos un archivo para systemd, para que corra Gunicorn como un servicio m\u00e1s:</p> <p></p> <p>Tened en cuenta que:</p> <ul> <li> <p><code>User</code>: Ser\u00e1 nuestro usuario.</p> </li> <li> <p><code>Group</code>: Pondremos <code>www-data</code></p> </li> <li> <p><code>Environment</code>: Establecemos el directorio <code>bin</code>. La ruta que guardamos antes pero sin el 'gunicorn'.</p> </li> <li> <p><code>WorkingDirectory</code>: El directorio donde tenemos el proyecto.</p> </li> <li> <p><code>ExecStart</code>: La ruta que guardamos antes para Gunicorn, completa.</p> </li> </ul> <p>Una vez configurado eso, habilitamos el servicio:</p> <pre><code>systemctl enable nombre_mi_servicio\n\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>El nombre del servicio es el nombre del archivo que creamos antes.</p> <p>Ahora deberemos configurar Nginx, yendo a la ruta de <code>/etc/nginx/sites-available/nombre_aplicacion</code>:</p> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion; \n\n\n\n    access_log /var/log/nginx/mi_aplicacion.access.log; \n\n\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock; \n\n\n    }\n}   \n</code></pre> <p></p> <p>Recordemos que ahora debemos crear un link simb\u00f3lico del archivo de sitios webs disponibles al de sitios web activos:</p> <p><code>sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/</code></p> <p>Y nos aseguramos de que se ha creado dicho link simb\u00f3lico:</p> <p><code>ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion</code></p> <p></p> <p>Como siempre, comprobamos que no haya errores y reiniciamos Nginx:</p> <pre><code>nginx -t\n\nsudo systemctl restart nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Como ya no podemos acceder por IP ya que la app est\u00e1 siendo servida por Gunicorn y Nginx, accedemos por el <code>server_name</code>.</p> <p>Debemos editar el archivo <code>hosts</code> de la m\u00e1quina anfitriona para a\u00f1adir la IP de la m\u00e1quina virtual y el nombre del proyecto:</p> <p></p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code></p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></p> <p>Ya guardado el archivo <code>hosts</code>, intentamos acceder a la web a trav\u00e9s de <code>http://nombre_aplicacion</code> o <code>http://www.nombre_aplicacion</code>:</p> <p></p> <p></p>"},{"location":"actividad_3.4/#mismo-proceso-con-un-repositorio-de-git","title":"Mismo proceso con un repositorio de Git","text":"<p>Primero, comenzamos con clonar el repositorio en cuesti\u00f3n:</p> <p><code>git clone https://github.com/raul-profesor/Practica-3.5</code></p> <p></p> <p>Lo siguiente que debemos hacer es dar los permisos necesarios a nuestra aplicaci\u00f3n, tal y como hicimos anteriormente, con los comandos, y siempre teniendo en cuenta que esta vez el nombre de la aplicaci\u00f3n es diferente:</p> <pre><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion\n\nchmod -R 775 /var/www/mi_aplicacion   \n</code></pre> <p></p> <p>Dentro del directorio de la app, creamos el archivo oculto <code>.env</code> para la creaci\u00f3n de otro entorno virtual:</p> <p><code>touch .env</code></p> <p>Y editamos el archivo para que quede as\u00ed:</p> <p></p> <p>Lanzamos el entorno virtual:</p> <p><code>pipenv shell</code></p> <p></p> <p>E instalamos las dependencias correspondientes:</p> <p><code>pipenv install -r requirements.txt</code></p> <p><code>pipenv install flask gunicorn</code></p> <p></p> <p></p> <p>Creamos el archivo <code>wsgi.py</code> solo ya que el otro no hace falta al existir ya uno:</p> <p><code>touch wsgi.py</code></p> <p>Y lo editamos para dejarlo as\u00ed:</p> <p></p> <p>Ya creado y guardado, probamos que lo corre, usando la direcci\u00f3n <code>0.0.0.0</code> como la otra vez:</p> <p><code>flask run --host '0.0.0.0'</code></p> <p>Y al entrar en la url <code>http://IP-maq-virtual:5000</code> deber\u00eda verse lo siguiente:</p> <p></p>"},{"location":"actividad_3.4/#comprobaacion-de-gunicorn-2","title":"Comprobaaci\u00f3n de Gunicorn 2","text":"<p>Si Flask ha funcionado bien, usando el siguiente comando nos dir\u00e1 si Gunicorn funciona:</p> <p><code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app</code></p> <p></p> <p>Todav\u00eda en el entorno virtual, vamos a tomar nota del path desde la que se ejecuta <code>gunicorn</code>, la vamos a necesitar para m\u00e1s adelante:</p> <p></p> <p>Como ya tendr\u00edamos que tener Nginx instalado en nuestro sistema por practicas anteriores, lo iniciamos y comprobamos su estado:</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Ya fuera del entorno virtual, creamos un archivo para systemd, para que corra Gunicorn como un servicio m\u00e1s:</p> <p></p> <p>Tened en cuenta que:</p> <ul> <li> <p><code>User</code>: Ser\u00e1 nuestro usuario.</p> </li> <li> <p><code>Group</code>: Pondremos <code>www-data</code></p> </li> <li> <p><code>Environment</code>: Establecemos el directorio <code>bin</code>. La ruta que guardamos antes pero sin el 'gunicorn'.</p> </li> <li> <p><code>WorkingDirectory</code>: El directorio donde tenemos el proyecto.</p> </li> <li> <p><code>ExecStart</code>: La ruta que guardamos antes para Gunicorn, completa.</p> </li> </ul> <p>Una vez configurado eso, habilitamos el servicio:</p> <pre><code>systemctl enable nombre_mi_servicio\n\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>El nombre del servicio es el nombre del archivo que creamos antes.</p> <p>Ahora deberemos configurar Nginx, yendo a la ruta de <code>/etc/nginx/sites-available/nombre_aplicacion</code>:</p> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion; \n\n\n\n    access_log /var/log/nginx/mi_aplicacion.access.log; \n\n\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock; \n\n\n    }\n}   \n</code></pre> <p></p> <p>Recordemos que ahora debemos crear un link simb\u00f3lico del archivo de sitios webs disponibles al de sitios web activos:</p> <p><code>sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/</code></p> <p>Y nos aseguramos de que se ha creado dicho link simb\u00f3lico:</p> <p><code>ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion</code></p> <p>Como siempre, comprobamos que no haya errores y reiniciamos Nginx:</p> <pre><code>nginx -t\n\nsudo systemctl restart nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Como ya no podemos acceder por IP ya que la app est\u00e1 siendo servida por Gunicorn y Nginx, accedemos por el <code>server_name</code>.</p> <p>Debemos editar el archivo <code>hosts</code> de la m\u00e1quina anfitriona para a\u00f1adir la IP de la m\u00e1quina virtual y el nombre del proyecto:</p> <p></p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code></p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></p> <p>Ya guardado el archivo <code>hosts</code>, intentamos acceder a la web a trav\u00e9s de <code>http://nombre_aplicacion</code> o <code>http://www.nombre_aplicacion</code>:</p> <p></p>"},{"location":"actividad_3.4/#cuestiones","title":"Cuestiones","text":"<pre><code>Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI.\n</code></pre> <p>Un servidor WSGI es como el intermediario que traduce entre un servidor web (como Nginx o Apache) y una aplicaci\u00f3n web hecha en Python (por ejemplo, Flask o Django). Recibe las solicitudes del navegador, las convierte en algo que la aplicaci\u00f3n entiende, y luego toma la respuesta de la aplicaci\u00f3n y se la devuelve al cliente en un formato listo para la web. Este est\u00e1ndar hace que cualquier servidor WSGI pueda trabajar con cualquier aplicaci\u00f3n Python compatible, facilitando el despliegue en producci\u00f3n, especialmente con herramientas como Gunicorn o uWSGI, que manejan m\u00faltiples solicitudes al mismo tiempo para maximizar el rendimiento.</p>"},{"location":"actividad_4.1/","title":"Practica 4.1 Configuraci\u00f3n de un servidor DNS","text":"<p>\u26a0\ufe0f Atenci\u00f3n: antes de empezar esta pr\u00e1ctica, elimina las entradas que se han introducido anteriormente en el archivo de <code>/etc/hosts</code> para que no interfiera con la pr\u00e1ctica.</p>"},{"location":"actividad_4.1/#instalacion-de-servidor-dns","title":"Instalaci\u00f3n de servidor DNS","text":"<p>Primero, instalaremos Bind, una herramienta para servidores DNS. Utilizaremos la versi\u00f3n Bind9, que es la recomendada para usarse.</p> <pre><code>sudo apt-get install bind9 bind9utils bind9-doc\n</code></pre> <p></p>"},{"location":"actividad_4.1/#configuracion-del-servidor","title":"Configuraci\u00f3n del servidor","text":"<p>Al ser una pr\u00e1ctica de clase, utilizaremos IPv4. Lo configuraremos a Bind a trav\u00e9s de un archivo llamado <code>named</code>, que se encuentra en el directorio <code>/etc/default</code>.</p> <p>Para indicar que se utilizar\u00e1 IPv4, tenemos que modificar esta l\u00ednea de la siguiente manera:</p> <pre><code>OPTIONS = \"-u bind -4\"\n</code></pre> <p></p> <p>Luego, el archivo en cuesti\u00f3n de configuraci\u00f3n principal se llama <code>named.conf</code> y est\u00e1 en el directorio <code>/etc/bind</code>.</p> <p>Al abrirlo lo que nos encontraremos ser\u00e1 lo siguiente:</p> <p></p>"},{"location":"actividad_4.1/#configuracion-de-namedconfoptions","title":"Configuraci\u00f3n de named.conf.options","text":"<p>Como es buena pr\u00e1ctica que se haga copia de seguridad de ciertos archivos, primero utilizaremos el siguiente comando para copiar:</p> <pre><code>sudo cp /etc/bind/named.conf.options /etc/bind/named.conf.options.backup\n</code></pre> <p></p> <p>Y a continuaci\u00f3n, ya editaremos el archivo <code>named.conf.options</code> para a\u00f1adir las l\u00edneas necesarias.</p> <ul> <li>Por seguridad, solo a\u00f1adiremos una lista de acceso para los hosts que decidamos. En mi caso, el ordenador que hace de host para la pr\u00e1ctica, con IP 192.168.X.0/24 (debemos cambiar la X por el de nuestra red). Debemos a\u00f1adir la l\u00ednea antes del bloque de <code>options {</code>.</li> </ul> <p></p> <p>Debemos tener en mente que el directorio donde se guardar\u00e1n las zonas por defecto es <code>/var/cache/bind</code>.</p> <p>A\u00f1adiremos luego unas l\u00edneas justo debajo del peque\u00f1o bloque de <code>forwarders {</code>.</p> <pre><code>allow-recursion {confiables;};\nallow-transfer{none;};\nlisten-on port 53{192.168.137.31;}; // Aqu\u00ed deb\u00e9is usar vuestra IP de la m\u00e1quina virtual\nrecursion yes;\n</code></pre> <p></p> <p>Una vez guardada la configuraci\u00f3n, podemos comprobar si todo sali\u00f3 bien, con el comando:</p> <pre><code>sudo named-checkconf\n</code></pre> <p>Si no sale nada, est\u00e1 todo bien.</p> <p></p> <p>Luego, reiniciamos el servidor y comprobamos el estado:</p> <pre><code>sudo systemctl restart named\n\nsudo systemctl status named\n</code></pre> <p></p>"},{"location":"actividad_4.1/#configuracion-de-namedconflocal","title":"Configuraci\u00f3n de named.conf.local","text":"<p>En este archivo lo que configuramos son las zonas. Para esta pr\u00e1ctica declaramos la zona <code>deaw.es</code>.</p> <p>A\u00f1adimos el siguiente bloque:</p> <pre><code>zone \"deaw.es\" {\n        type master;\n        file \"/etc/bind/db.deaw.es\";\n};\n</code></pre> <p></p>"},{"location":"actividad_4.1/#creacion-del-archivo-de-zona","title":"Creaci\u00f3n del archivo de zona","text":"<p>Este archivo deberemos crearlo, con el nombre que declaramos en el anterior archivo. En mi caso es <code>db.deaw.es</code>.</p> <p>Se debe hacer de la siguiente manera, respetando el formato:</p> <p></p> <p>En mi caso he puesto las dos IPs, la del host y la de la m\u00e1quina virtual.</p>"},{"location":"actividad_4.1/#creacion-del-archivo-de-zona-para-la-resolucion-inversa","title":"Creaci\u00f3n del archivo de zona para la resoluci\u00f3n inversa","text":"<p>Como deben existir dos archivos de zona, uno para resoluci\u00f3n directa y otro para la inversa, crearemos otro para la zona inversa.</p> <p>Primero, debemos tener en cuenta que se tienen que a\u00f1adir unas l\u00edneas m\u00e1s en el archivo anterior de <code>named.conf.local</code>, de la misma manera en la que hemos a\u00f1adido la primera zona para <code>deaw.es</code>, donde las X de las IP deben ser sustitu\u00eddas por las nuestras.</p> <pre><code>zone \"X.168.192.in-addr.arpa\" {\n        type master;\n        file \"/etc/bind/db.X.168.192\";\n};\n</code></pre> <p></p> <p>Y tal como hemos hecho antes, tambi\u00e9n haremos un archivo para la resoluci\u00f3n inversa de esta nueva zona, donde la X ser\u00e1 sustituida por el final de nuestras IP:</p> <p></p>"},{"location":"actividad_4.1/#comprobacion-de-las-configuraciones","title":"Comprobaci\u00f3n de las configuraciones","text":"<ul> <li>Para comprobar la configuraci\u00f3n de la zona de resoluci\u00f3n directa, donde X se cambia por vuestra IP:</li> </ul> <pre><code>sudo named-checkzone db.deaw.es db.X.168.192\n</code></pre> <ul> <li>Y la comprobaci\u00f3n de la resoluci\u00f3n inversa:</li> </ul> <pre><code>sudo named-checkzone db.X.168.192 db.deaw.es\n</code></pre> <p>En caso de que todo est\u00e9 bien, reiniciamos el servicio de nuevo para comprobar que todo est\u00e1 OK.</p> <p></p>"},{"location":"actividad_4.1/#comprobacion-de-las-resoluciones-y-de-las-consultas","title":"Comprobaci\u00f3n de las resoluciones y de las consultas","text":"<p>Desde los clientes, podemos comprobar las resoluciones directas e inversas con los comandos de dig o nslookup:</p> <ul> <li>Comprobaci\u00f3n usando <code>nslookup</code>:</li> </ul> <p> </p> <ul> <li>Comprobaci\u00f3n usando <code>dig</code>:</li> </ul> <p> </p>"},{"location":"actividad_4.1/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_4.1/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>\u00bfQu\u00e9 pasar\u00e1 si un cliente de una red diferente a la tuya intenta hacer uso de tu DNS de alguna manera, le funcionar\u00e1? \u00bfPor qu\u00e9, en qu\u00e9 parte de la configuraci\u00f3n puede verse?</p> <p>No, si no le has dado permiso, no podr\u00e1 acceder. La configuraci\u00f3n <code>allow-query</code> en tu DNS es donde decides qui\u00e9n puede hacer consultas.</p>"},{"location":"actividad_4.1/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>\u00bfPor qu\u00e9 tenemos que permitir las consultas recursivas en la configuraci\u00f3n?</p> <p>Porque sin ellas, tu servidor no podr\u00e1 buscar dominios fuera de su zona. B\u00e1sicamente, no podr\u00eda hacer consultas completas, solo resolver los nombres que ya conoce.</p>"},{"location":"actividad_4.1/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>El servidor DNS que acab\u00e1is de montar, \u00bfes autoritativo? \u00bfPor qu\u00e9?</p> <p>S\u00ed, porque es el encargado de gestionar y dar respuestas sobre las zonas que hemos configurado. Es el jefe en ese dominio.</p>"},{"location":"actividad_4.1/#cuestion-4","title":"Cuesti\u00f3n 4","text":"<p>\u00bfD\u00f3nde podemos encontrar la directiva $ORIGIN y para qu\u00e9 sirve?</p> <p>Est\u00e1 en los archivos de zona. Sirve para definir el dominio base y evitar que tengas que escribirlo todo el tiempo.</p>"},{"location":"actividad_4.1/#cuestion-5","title":"Cuesti\u00f3n 5","text":"<p>\u00bfUna zona es id\u00e9ntico a un dominio?</p> <p>No son lo mismo. La zona es la parte del dominio que el servidor DNS gestiona, pero no siempre coincide uno a uno con el dominio.</p>"},{"location":"actividad_4.1/#cuestion-6","title":"Cuesti\u00f3n 6","text":"<p>\u00bfPueden editarse los archivos de zona de un servidor esclavo/secundario?</p> <p>No, solo el maestro puede hacer cambios. Los esclavos solo sirven la info que les pasan.</p>"},{"location":"actividad_4.1/#cuestion-7","title":"Cuesti\u00f3n 7","text":"<p>\u00bfPor qu\u00e9 podr\u00eda querer tener m\u00e1s de un servidor esclavo para una misma zona?</p> <p>Para que si uno se cae, otro pueda seguir funcionando. Y tambi\u00e9n para repartir la carga de consultas.</p>"},{"location":"actividad_4.1/#cuestion-8","title":"Cuesti\u00f3n 8","text":"<p>\u00bfCu\u00e1ntos servidores ra\u00edz existen?</p> <p>Hay 13, aunque no son solo 13 f\u00edsicos, est\u00e1n distribuidos por todo el mundo.</p>"},{"location":"actividad_4.1/#cuestion-9","title":"Cuesti\u00f3n 9","text":"<p>\u00bfQu\u00e9 es una consulta iterativa de referencia?</p> <p>Es cuando tu servidor no tiene la respuesta y le dice al cliente \u201cve a preguntar a otro servidor\u201d.</p>"},{"location":"actividad_4.1/#cuestion-10","title":"Cuesti\u00f3n 10","text":"<p>En una resoluci\u00f3n inversa, \u00bfa qu\u00e9 nombre se mapear\u00eda la direcci\u00f3n IP 172.16.34.56?</p> <p>Se mapear\u00eda a <code>56.34.16.172.in-addr.arpa</code>, que es la forma de hacer una b\u00fasqueda inversa en DNS.</p>"},{"location":"actividad_6.1/","title":"Pr\u00e1ctica 6.1 - Dockerizaci\u00f3n del despliegue de una aplicaci\u00f3n Node.js","text":""},{"location":"actividad_6.1/#despliegue-con-docker","title":"Despliegue con Docker","text":"<p>Empezaremos con lo b\u00e1sico, debiendo clonar el siguiente repositorio para la pr\u00e1ctica:</p> <pre><code>git clone https://github.com/raul-profesor/DAW_practica_6.1_2024.git\n</code></pre> <p></p> <p>El repositorio en si contiene el <code>Dockerfile</code> necesario para construir la imagen y correr el contenedor, pero se hablar\u00e1 sobre \u00e9l m\u00e1s tarde.</p>"},{"location":"actividad_6.1/#instalacion-de-docker","title":"Instalaci\u00f3n de Docker","text":"<p>Antes de seguir, instalaremos Docker en nuestro sistema. Para ello, utilizaremos el siguiente comando:</p> <pre><code>sudo apt install -y docker.io\n</code></pre> <p></p>"},{"location":"actividad_6.1/#archivo-dockfile","title":"Archivo Dockfile","text":"<p>Ahora que s\u00ed tenemos instalado Docker, buscamos el archivo <code>Dockerfile</code> del repositorio que hemos clonado, y rellenamos lo que falta, quedando asi:</p> <p></p> <p>Donde con lo que completamos har\u00e1 que:</p> <ul> <li><code>RUN mkdir -p /opt/app</code> : Crea el directorio /opt/app en el contenedor.</li> <li><code>WORKDIR /opt/app</code>: Establece /opt/app como directorio de trabajo.</li> <li><code>COPY src/package.json src/package-lock.json ./</code>: Copia ficheros package.json y package-lock.json desde el src/ al directorio de trabajo.</li> <li><code>RUN npm intsall</code> : Instala las dependencias de la aplicaci\u00f3n.</li> <li><code>COPY src/ .</code> : Copia el resto del c\u00f3digo de la carpeta src/ al contenedor.</li> <li><code>EXPOSE 3000</code> : Expone el puerto 3000 para que la app se pueda acceder desde fuera del contenedor en s\u00ed.</li> <li><code>CMD [\"npm\", \"run\", \"start:dev\"]</code> : Arranca la aplicaci\u00f3n en modo desarrollo.</li> </ul>"},{"location":"actividad_6.1/#construccion-de-la-imagen","title":"Construcci\u00f3n de la imagen","text":"<p>En el contexto del directorio actual de trabajo, hacemos el build de la imagen, bajo el nombre de <code>librodirecciones</code>.</p> <pre><code>sudo docker build -t librodirecciones .\n</code></pre> <p> </p> <p>Lo siguiente ser\u00e1 iniciar el contenedor en modo demonio, para ponerlo y que escuche las peticiones del puerto 3000, y que coincida con el puerto 3000 del contenedor en s\u00ed.</p> <pre><code>docker run -p 3000:3000 -d librodirecciones\n</code></pre> <p></p> <p>Si ahora intentamos acceder a nuestro <code>http://IP_Maq_Virtual:3000</code>, se produce un error de conexi\u00f3n.</p> <p></p>"},{"location":"actividad_6.1/#docker-compose","title":"Docker Compose","text":"<p>Para continuar, instalaremos Docker Compose en nuestro sistema, usando el siguiente comando:</p> <pre><code>sudo apt install docker-compose\n</code></pre> <p></p> <p>Una vez instalado comprobamos la versi\u00f3n:</p> <pre><code>docker-compose --version\n</code></pre> <p></p> <p>Si no viniese el archivo, se deber\u00e1 crear un <code>docker-compose.yml</code> en el directorio ra\u00edz del repositorio que hemos clonado.</p> <p>Deber\u00eda tener el pr\u00f3ximo contenido:</p> <pre><code>version: \"3.9\"\nservices:\n  postgres:\n    image: postgres:latest\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    ports: \n      - '5432:5432'\n    volumes:\n      - addressbook-db:/var/lib/postgresql/data\n\n  addressbook:\n    build:\n      context: .\n    environment:\n      DB_SCHEMA: postgres\n      DB_USER: postgres\n      DB_PASSWORD: postgres\n      DB_HOST: postgres\n    depends_on:\n      - postgres\n    ports:\n      - '3000:3000'\n\nvolumes:\n  addressbook-db:\n</code></pre> <p></p> <p>Antes de iniciar los contenedores, vamos a crear una estructura para la base de datos. Para ello, usamos el siguiente comando:</p> <pre><code>sudo docker-compose run addressbook npm run migrate\n</code></pre> <p> </p> <p>Y ahora S\u00cd podemos iniciar los contenedores:</p> <pre><code>sudo docker-compose up --build -d\n</code></pre> <p></p> <p>Podemos testear con el siguiente comando para ver que nos da una salida parecida a esto:</p> <pre><code>sudo docker-compose run addressbook npm test\n</code></pre> <p> </p>"},{"location":"actividad_6.1/#tarea-final","title":"Tarea final","text":"<p>Vamos a probar que la aplicaci\u00f3n junto con la BBDD funciona. Para ello probaremos los siguientes comandos:</p> <ul> <li><code>curl -X PUT http://localhost:3000/persons -H 'Content-Type: application/json' -d '{\"id\": 1, \"firstName\": \"Ra\u00fal\", \"lastName\": \"Profesor\"}'</code> : Para a\u00f1adir una persona.</li> <li><code>curl -X GET http://localhost:3000/persons/all -H 'Content-Type: application/json'</code> : Para listar todas las personas.</li> <li><code>curl -X GET http://localhost:3000/persons/1 -H 'Content-Type: application/json'</code> : Para buscar una persona por ID.</li> <li><code>curl -X DELETE http://localhost:3000/persons/1 -H 'Content-Type: application/json'</code> : Eliminar una persona.</li> </ul> <p>Si todos salen bien, deber\u00edan salir de esta manera:</p> <p></p>"},{"location":"actividad_git1/","title":"Practica Git y GitHub I","text":""},{"location":"actividad_git1/#crear-y-configurar-el-repositorio","title":"Crear y configurar el repositorio","text":"<ol> <li>Crea un repositorio en tu cuenta de GitHub llamado <code>DEAW</code>.</li> <li>Cl\u00f3nalo en tu ordenador para trabajar en local.</li> </ol>"},{"location":"actividad_git1/#readme-primeros-pasos-con-git","title":"README + Primeros pasos con Git","text":"<ol> <li>Si a\u00fan no lo hiciste, crea un archivo <code>README.md</code> en tu repositorio local.</li> <li>Escribe un peque\u00f1o texto explicando para qu\u00e9 se usar\u00e1 el repositorio y en qu\u00e9 m\u00f3dulo.</li> <li>Haz un commit inicial con el mensaje: <code>Comenzamos con los ejercicios de Git</code>.</li> <li>Sube los cambios al repositorio remoto con un push.</li> </ol>"},{"location":"actividad_git1/#ignorar-archivos","title":"Ignorar archivos","text":"<ol> <li>Crea un archivo llamado <code>privado.txt</code> en tu repositorio local.</li> <li>Crea una carpeta llamada <code>privada</code> en tu repositorio local.</li> <li>Configura Git para que ignore tanto el archivo como la carpeta.</li> </ol>"},{"location":"actividad_git1/#anadir-archivos-y-etiquetas","title":"A\u00f1adir archivos y etiquetas","text":"<ol> <li>A\u00f1ade un archivo <code>1.txt</code> al repositorio local.</li> <li>Crea un tag <code>v0.1</code>.</li> <li>Sube los cambios al repositorio remoto, incluyendo el tag.</li> </ol>"},{"location":"actividad_git1/#configuracion-de-la-cuenta-de-github","title":"Configuraci\u00f3n de la cuenta de GitHub","text":"<ol> <li>Pon una foto de perfil en tu cuenta de GitHub.</li> <li>Activa la autenticaci\u00f3n en dos pasos en GitHub.</li> </ol>"},{"location":"actividad_git1/#uso-social-de-github","title":"Uso social de GitHub","text":"<ol> <li>Sigue en GitHub a dos compa\u00f1eros de clase.</li> <li>Sigue los repos DEAW del resto de tus compa\u00f1eros.</li> <li>Dale una estrella a los repos DEAW de tus compa\u00f1eros.</li> </ol>"},{"location":"actividad_git1/#crear-una-tabla-en-el-readme","title":"Crear una tabla en el README","text":"<ol> <li>A\u00f1ade esta tabla al <code>README.md</code> con informaci\u00f3n de varios compa\u00f1eros:</li> </ol>"},{"location":"actividad_git1/#anadir-colaboradores","title":"A\u00f1adir colaboradores","text":"<ol> <li>Agrega a <code>github.com/raul-profesor</code> como colaborador en el repositorio <code>DEAW</code>.</li> </ol>"},{"location":"actividad_git1/#trabajo-con-ramas","title":"Trabajo con ramas","text":"<ol> <li>Crea una rama <code>v0.2</code>.</li> <li>C\u00e1mbiate a la rama <code>v0.2</code>.</li> <li>A\u00f1ade un archivo <code>2.txt</code> en la rama <code>v0.2</code>.</li> <li>Sube la rama <code>v0.2</code> al repositorio remoto.</li> </ol>"},{"location":"actividad_git1/#merge-directo","title":"Merge directo","text":"<ol> <li>C\u00e1mbiate a la rama <code>master</code>.</li> <li>Haz un merge de <code>v0.2</code> en <code>master</code>.</li> </ol>"},{"location":"actividad_git1/#merge-con-conflicto","title":"Merge con conflicto","text":"<ol> <li>En la rama <code>master</code>, escribe <code>Hola</code> en <code>1.txt</code> y haz commit.</li> <li>En la rama <code>v0.2</code>, escribe <code>Adios</code> en <code>1.txt</code> y haz commit.</li> <li>C\u00e1mbiate a <code>master</code> y haz merge con <code>v0.2</code> (esto generar\u00e1 un conflicto).</li> </ol>"},{"location":"actividad_git1/#resolver-conflictos","title":"Resolver conflictos","text":"<ol> <li>Lista las ramas con y sin merge.</li> <li>Resuelve el conflicto anterior y haz un commit.</li> </ol>"},{"location":"actividad_git1/#borrar-ramas","title":"Borrar ramas","text":"<ol> <li>Crea un tag <code>v0.2</code>.</li> <li>Borra la rama <code>v0.2</code>.</li> </ol>"},{"location":"actividad_git1/#listado-de-cambios","title":"Listado de cambios","text":"<ol> <li>Lista todos los commits, ramas y tags del repositorio.</li> </ol>"},{"location":"actividad_git2/","title":"Practica Git y GitHub II","text":""},{"location":"actividad_git2/#ejercicios-de-creacion-y-actualizacion-de-repositorios","title":"Ejercicios de creaci\u00f3n y actualizaci\u00f3n de repositorios","text":""},{"location":"actividad_git2/#ejercicio-1","title":"Ejercicio 1","text":"<p>Configurar Git definiendo el nombre del usuario, el correo electr\u00f3nico y activar el coloreado de la salida.</p> <p>Mostrar la configuraci\u00f3n final.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-2","title":"Ejercicio 2","text":"<p>Crear un repositorio nuevo con el nombre libro y mostrar su contenido.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-3","title":"Ejercicio 3","text":"<p>Comprobar el estado del repositorio.</p> <p>Crear un fichero indice.txt con el siguiente contenido:</p> <pre><code>Cap\u00edtulo 1: Introducci\u00f3n a Git\nCap\u00edtulo 2: Flujo de trabajo b\u00e1sico\nCap\u00edtulo 3: Repositorios remotos\n</code></pre> <p>Comprobar de nuevo el estado del repositorio.</p> <p>A\u00f1adir el fichero a la zona de intercambio temporal.</p> <p>Volver a comprobar una vez m\u00e1s el estado del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-4","title":"Ejercicio 4","text":"<p>Realizar un commit de los \u00faltimos cambios con el mensaje \u201cA\u00f1adido \u00edndice del libro.\u201d y ver el estado del repositorio.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-5","title":"Ejercicio 5","text":"<p>Cambiar el fichero indice.txt para que contenga lo siguiente:</p> <pre><code>Cap\u00edtulo 1: Introducci\u00f3n a Git\nCap\u00edtulo 2: Flujo de trabajo b\u00e1sico\nCap\u00edtulo 3: Gesti\u00f3n de ramas\nCap\u00edtulo 4: Repositorios remotos\n</code></pre> <p>Mostrar los cambios con respecto a la \u00faltima versi\u00f3n guardada en el repositorio.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas\u201d.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-6","title":"Ejercicio 6","text":"<p>Mostrar los cambios de la \u00faltima versi\u00f3n del repositorio con respecto a la anterior.</p> <p>Cambiar el mensaje del \u00faltimo commit por \u201cA\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas al \u00edndice.\u201d</p> <p>Volver a mostrar los \u00faltimos cambios del repositorio.</p> <p></p>"},{"location":"actividad_git2/#ejercicios-de-manejo-del-historial-de-cambios","title":"Ejercicios de manejo del historial de cambios","text":""},{"location":"actividad_git2/#ejercicio-1_1","title":"Ejercicio 1","text":"<p>Mostrar el historial de cambios del repositorio.</p> <p>Crear la carpeta capitulos y crear dentro de ella el fichero capitulo1.txt con el siguiente texto.</p> <p>Git es un sistema de control de versiones ideado por Linus Torvalds.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 1.\u201d </p> <p>Volver a mostrar el historial de cambios del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-2_1","title":"Ejercicio 2","text":"<p>Crear el fichero capitulo2.txt en la carpeta capitulos con el siguiente texto.</p> <p>El flujo de trabajo b\u00e1sico con Git consiste en: 1- Hacer cambios en el repositorio. 2- A\u00f1adir los cambios a la zona de intercambio temporal. 3- Hacer un commit de los cambios.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 2.\u201d</p> <p>Mostrar las diferencias entre la \u00faltima versi\u00f3n y dos versiones anteriores.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-3_1","title":"Ejercicio 3","text":"<p>Crear el fichero capitulo3.txt en la carpeta capitulos con el siguiente texto.</p> <p>Git permite la creaci\u00f3n de ramas lo que permite tener distintas versiones del mismo proyecto y trabajar de manera simultanea en ellas.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 3.\u201d</p> <p>Mostrar las diferencias entre la primera y la \u00faltima versi\u00f3n del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-4_1","title":"Ejercicio 4","text":"<p>A\u00f1adir al final del fichero indice.txt la siguiente l\u00ednea:</p> <p>Cap\u00edtulo 5: Conceptos avanzados</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 5 al \u00edndice.\u201d.</p> <p>Mostrar qui\u00e9n ha hecho cambios sobre el fichero indice.txt.</p> <p> </p>"},{"location":"actividad_git2/#ejercicios-de-deshacer-cambios","title":"Ejercicios de deshacer cambios","text":""},{"location":"actividad_git2/#ejercicio-1_2","title":"Ejercicio 1","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero indice.txt y guardarlo. (Solo mostrar\u00e9 el archivo con la l\u00ednea eliminada en este primer ejercicio, en los dem\u00e1s, se dar\u00e1 por hecho para no tener que repetir la imagen varias veces.)</p> <p>Comprobar el estado del repositorio.</p> <p>Deshacer los cambios realizados en el fichero indice.txt para volver a la versi\u00f3n anterior del fichero.</p> <p>Volver a comprobar el estado del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-2_2","title":"Ejercicio 2","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero indice.txt y guardarlo.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Deshacer los cambios realizados en el fichero indice.txt para volver a la versi\u00f3n anterior del fichero.</p> <p>Volver a comprobar el estado del repositorio.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-3_2","title":"Ejercicio 3","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero indice.txt y guardarlo.</p> <p>Eliminar el fichero capitulos/capitulo3.txt.</p> <p>A\u00f1adir un fichero nuevo capitulos/capitulo4.txt vac\u00edo.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Deshacer los cambios realizados para volver a la versi\u00f3n del repositorio.</p> <p>Volver a comprobar el estado del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-4_2","title":"Ejercicio 4","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero indice.txt y guardarlo.</p> <p>Eliminar el fichero capitulos/capitulo3.txt.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cBorrado accidental.\u201d</p> <p>Comprobar el historial del repositorio.</p> <p>Deshacer el \u00faltimo commit pero mantener los cambios anteriores en el directorio de trabajo y la zona de intercambio temporal.</p> <p>Comprobar el historial y el estado del repositorio.</p> <p>Volver a hacer el commit con el mismo mensaje de antes.</p> <p>Deshacer el \u00faltimo commit y los cambios anteriores del directorio de trabajo volviendo a la versi\u00f3n anterior del repositorio.</p> <p>Comprobar de nuevo el historial y el estado del repositorio.</p> <p> </p>"},{"location":"actividad_git2/#ejercicios-de-gestion-de-ramas","title":"Ejercicios de gesti\u00f3n de ramas","text":""},{"location":"actividad_git2/#ejercicio-1_3","title":"Ejercicio 1","text":"<p>Crear una nueva rama bibliografia y mostrar las ramas del repositorio.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-2_3","title":"Ejercicio 2","text":"<p>Crear el fichero capitulos/capitulo4.txt y a\u00f1adir el texto siguiente</p> <p>En este cap\u00edtulo veremos c\u00f3mo usar GitHub para alojar repositorios en remoto.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adido cap\u00edtulo 4.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-3_3","title":"Ejercicio 3","text":"<p>Cambiar a la rama bibliografia.</p> <p>Crear el fichero bibliografia.txt y a\u00f1adir la siguiente referencia</p> <p>Chacon, S. and Straub, B. Pro Git. Apress.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adida primera referencia bibliogr\u00e1fica.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-4_3","title":"Ejercicio 4","text":"<p>Fusionar la rama bibliografia con la rama master.</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p>Eliminar la rama bibliografia.</p> <p>Mostrar de nuevo la historia del repositorio incluyendo todas las ramas.</p>"},{"location":"actividad_git2/#ejercicio-5_1","title":"Ejercicio 5","text":"<p>Crear la rama bibliografia.</p> <p>Cambiar a la rama bibliografia.</p> <p>Cambiar el fichero bibliografia.txt para que contenga las siguientes referencias:</p> <p>Scott Chacon and Ben Straub. Pro Git. Apress. Ryan Hodson. Ry\u2019s Git Tutorial. Smashwords (2014)</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cA\u00f1adida nueva referencia bibliogr\u00e1fica.\u201d</p> <p>Cambiar a la rama master.</p> <p>Cambiar el fichero bibliografia.txt para que contenga las siguientes referencias:</p> <p>Chacon, S. and Straub, B. Pro Git. Apress. Loeliger, J. and McCullough, M. Version control with Git. O\u2019Reilly.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cA\u00f1adida nueva referencia bibliogr\u00e1fica.\u201d</p> <p>Fusionar la rama bibliografia con la rama master.</p> <p>Resolver el conflicto dejando el fichero bibliografia.txt con las referencias:</p> <p>Chacon, S. and Straub, B. Pro Git. Apress. Loeliger, J. and McCullough, M. Version control with Git. O\u2019Reilly. Hodson, R. Ry\u2019s Git Tutorial. Smashwords (2014)</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cResuelto conflicto de bibliograf\u00eda.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p> </p>"},{"location":"actividad_git2/#ejercicios-de-repositorios-remotos","title":"Ejercicios de repositorios remotos","text":""},{"location":"actividad_git2/#ejercicio-1_4","title":"Ejercicio 1","text":"<p>Crear un nuevo repositorio p\u00fablico en GitHub con el nombre libro-git.</p> <p>A\u00f1adirlo al repositorio local del libro.</p> <p>Mostrar todos los repositorios remotos configurados.</p> <p></p>"},{"location":"actividad_git2/#ejercicio-2_4","title":"Ejercicio 2","text":"<p>A\u00f1adir los cambios del repositorio local al repositorio remoto de GitHub.</p> <p>Acceder a GitHub y comprobar que se han subido los cambios mostrando el historial de versiones.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-3_4","title":"Ejercicio 3","text":"<p>Colaborar en el repositorio remoto libro-git de otro usuario.</p> <p>Clonar su repositorio libro-git.</p> <p>A\u00f1adir el fichero autores.txt que contenga el nombre del usuario y su correo electr\u00f3nico.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adido autor.\u201d</p> <p>Subir los cambios al repositorio remoto.</p> <p> </p>"},{"location":"actividad_git2/#ejercicio-4_4","title":"Ejercicio 4","text":"<p>Hacer una bifurcaci\u00f3n del repositorio remoto asalber/libro-git en GitHub.</p> <p>Clonar el repositorio creado en la cuenta de GitHub del usuario.</p> <p>Crear una nueva rama autoria y activarla.</p> <p>A\u00f1adir el nombre del usuario y su correo al fichero autores.txt.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adido nuevo autor.\u201d</p> <p>Subir los cambios de la rama autoria al repositorio remoto en GitHub.</p> <p>Hacer un Pull Request de los cambios en la rama autoria. </p> <p> </p>"},{"location":"ampliacion/","title":"Pr\u00e1ctica de Ampliaci\u00f3n","text":""},{"location":"ampliacion/#configuracion-de-un-servidor-nginx-con-hosts-virtuales-y-directorios-de-usuario","title":"Configuraci\u00f3n de un servidor Nginx con Hosts Virtuales y directorios de usuario","text":"<p>Como para esta pr\u00e1ctica se han reutilizado m\u00e1quinas virtuales que ya estaban configuradas para este tipo de cosas, hay algunos pasos que no han sido detallados, pero aun as\u00ed ser\u00e1n mencionados.</p>"},{"location":"ampliacion/#maquina-virtual-con-debian","title":"M\u00e1quina Virtual con Debian","text":"<p>En mi caso ya ten\u00eda una configurada, as\u00ed que simplemente la clon\u00e9 para trabajar desde una nueva, indicando que generase nuevas IP y as\u00ed no mezclarse con la otra.</p>"},{"location":"ampliacion/#conexion-por-ssh","title":"Conexi\u00f3n por SSH","text":"<p>Para conectarnos a nuestra m\u00e1quina virtual por SSH, todo lo que tenemos que hacer es abrir la consola de comandos e introducir el siguiente comando, donde la IP debe corresponder a la de la m\u00e1quina virtual, no la de la m\u00e1quina anfitriona:</p> <pre><code>ssh &lt;usuario&gt;@192.168.137.31\n</code></pre> <p>Una vez conectados podemos manejarlo todo desde esa consola.</p>"},{"location":"ampliacion/#instalacion-de-nginx","title":"Instalaci\u00f3n de Nginx","text":"<p>En mi caso, Nginx ya estaba instalado, pero para comprobar que todo estaba bien, utilic\u00e9 el siguiente comando para comprobar que funcionando:</p> <pre><code>systemctl status nginx\n</code></pre> <p></p> <p></p> <p>De todas formas, si hiciese falta instalar Nginx en s\u00ed, lo mejor y m\u00e1s r\u00e1pido es instalarlo a trav\u00e9s del gestor de paquetes con los siguientes comandos:</p> <pre><code>sudo apt-get update \nsudo apt-get upgrade \nsudo apt-get install nginx\n</code></pre> <p>No har\u00eda falta configurar nada m\u00e1s, ya que la configuraci\u00f3n que viene por defecto deber\u00eda ser suficiente para esta pr\u00e1ctica.</p>"},{"location":"ampliacion/#creacion-de-usuarios-del-sistema","title":"Creaci\u00f3n de usuarios del sistema","text":"<p>Para la pr\u00e1ctica vamos a crear dos usuarios diferentes de manera sencilla.</p> <p>Haremos usuarios b\u00e1sicos, ya que no hace falta mucho m\u00e1s para esta actividad. Para ello, lo que s\u00ed vamos a tener en cuenta es que m\u00e1s adelante crearemos carpetas para cada usuario.</p> <p>Para la creaci\u00f3n del usuario, debemos utilizar los siguientes comandos:</p> <pre><code>sudo useradd -m -s /bin/bash &lt;usuario&gt;\nsudo passwd &lt;usuario&gt;\n</code></pre> <p></p> <p>Obviamente, debemos usar los comandos dos veces para crear dos usuarios esta vez.</p>"},{"location":"ampliacion/#estructura-de-carpetas","title":"Estructura de carpetas","text":"<p>Lo pr\u00f3ximo ser\u00eda crear una carpeta por usuario nuevo para que cada uno tenga su web. Como Nginx intenta acceder a <code>public_html</code> (que es como se llama por defecto la carpeta donde estar\u00e1 la p\u00e1gina web), crearemos esta carpeta para cada usuario.</p> <p>Para ello debemos seguir los siguientes pasos:</p> <ul> <li>Iniciamos sesi\u00f3n con el primer usuario y revisamos que estamos en su home.</li> </ul> <pre><code>su &lt;usuario&gt;\ncd\n</code></pre> <ul> <li>Creamos la carpeta de <code>public_html</code>.</li> </ul> <pre><code>mkdir public_html\n</code></pre> <ul> <li>Para dar permisos a Nginx, utilizaremos un comando que nos deja darlos de manera m\u00e1s r\u00e1pida:</li> </ul> <pre><code>setfacl -d -R -m u:www-data:rw public_html\n</code></pre> <p>Ten en cuenta que estos pasos se deben seguir DOS veces. Para configurarlo en los dos nuevos usuarios.</p> <p>Y para comprobar que funciona y que se tienen los permisos necesarios, podemos comprobarlo con el siguiente comando:</p> <pre><code>getfacl &lt;ruta_de_carpeta&gt;\n</code></pre> <p></p> <p></p>"},{"location":"ampliacion/#contenido-web","title":"Contenido web","text":"<p>Como lo \u00fanico que crearemos ser\u00e1n p\u00e1ginas web sencillas para ver que funciona, vamos a crear un archivo <code>index.html</code> para cada usuario en la carpeta de <code>public_html</code>.</p> <p>Para ello, debemos iniciar sesi\u00f3n con el usuario en s\u00ed, siguiendo los mismos comandos de antes, y una vez en la carpeta, utilizamos el comando <code>nano index.html</code> para crear el archivo en s\u00ed.</p> <p></p> <p>Pod\u00e9is poner lo que quer\u00e1is, pero la estructura b\u00e1sica a seguir es la siguiente:</p> <p></p> <p></p>"},{"location":"ampliacion/#creacion-de-los-hosts-virtuales","title":"Creaci\u00f3n de los hosts virtuales","text":"<p>Crearemos unos archivos para que desde HTTP nos redirija a HTTPS.</p> <p>Para ello, deberemos ir a la carpeta de sitios web disponibles en <code>/etc/nginx/sites-available/nombre_de_la_web</code> y entrar en una de ellas. Recordad que debemos seguir los pasos x2 al tener dos usuarios y dos webs diferentes.</p> <p>Una vez dentro, utilizamos el comando <code>sudo nano &lt;nombre&gt;</code> para crear un archivo que tendr\u00e1 la siguiente configuraci\u00f3n:</p> <pre><code># Este bloque es la configuraci\u00f3n para el host en puerto 443\nserver {\n\n    listen 443 ssl; \n    listen [::]:443 ssl;\n\n    root &lt;direccion_raiz_servidor&gt;;\n\n    ssl_certificate &lt;direccion_certificado_tls-ssl&gt;;\n    ssl_certificate_key &lt;direccion_clave_privada_certificado_tls-ssl&gt;;\n\n    index index.html;\n\n    server_name &lt;nombre_host&gt;; \n\n    location / {\n        return 301 https://$host:$request_uri; \n    }\n}\n\n# Este bloque hace referencia a la redirecci\u00f3n\nserver {\n\n    listen 80; \n    listen [::]:80;\n\n    server_name &lt;nombre_host&gt;; \n\n    location / {\n        return 301 https://$host:$request_uri; \n    }\n}\n</code></pre> <p></p> <p></p> <p>Una vez hecho eso, debemos crear los enlaces simb\u00f3licos para 'activar' las webs en <code>/etc/nginx/sites-enabled/</code>, las cuales tambi\u00e9n debemos repetir dos veces para las dos webs.</p> <pre><code>sudo ln -s /etc/nginx/sites-available/&lt;archivo_de_configuraci\u00f3n&gt; /etc/nginx/sites-enabled\n</code></pre> <p>Y para comprobar que todo est\u00e1 correcto:</p> <pre><code>sudo nginx -t\n</code></pre> <p>Una vez comprobado que todo est\u00e1 bien, se reinicia Nginx:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p> <p></p>"},{"location":"ampliacion/#configurar-el-archivo-hosts","title":"Configurar el archivo hosts","text":"<p>Como en pr\u00e1cticas anteriores, debemos a\u00f1adir los dominios e IPs de nuestros servidores para que se haga referencia a la m\u00e1quina virtual.</p> <p>Para ello, solo debemos abrir el archivo <code>hosts</code>, que en mi caso (Windows) se encuentra en <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> y a\u00f1adir la IP de la m\u00e1quina virtual y los nombres de los dominios.</p> <p></p>"},{"location":"ampliacion/#generacion-de-certificados-para-https","title":"Generaci\u00f3n de certificados para HTTPS","text":"<p>Para que la web sirva con HTTPS, necesitamos certificados, pero como esto es una pr\u00e1ctica y no una web real, generaremos un certificado para cada usuario que hemos creado.</p> <p>Yo ya ten\u00eda alg\u00fan certificado de antes, pero por si acaso, gener\u00e9 uno por usuario para no pillarme los dedos.</p> <p>Podemos hacerlo con el siguiente comando, gener\u00e1ndolos en el directorio <code>/etc/ssl/certs</code> y la clave correspondiente en <code>/etc/ssl/private</code>:</p> <pre><code>openssl req -x509 -newkey rsa:4096 -keyout &lt;private_key_file&gt; -out &lt;certificate_file&gt; -sha256 -days 365 --nodes\n</code></pre> <p>Deber\u00eda quedar algo as\u00ed:</p> <p></p> <p></p>"},{"location":"ampliacion/#comprobacion-final","title":"Comprobaci\u00f3n final","text":"<p>Una vez hecho todo lo anterior, deber\u00edamos poder acceder a los dominios y ser redirigidos a su versi\u00f3n HTTPS, al igual que cada web deber\u00eda mostrar su propio certificado:</p> <p></p> <p></p> <p></p> <p></p>"}]}