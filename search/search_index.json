{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"actividad_2.1/","title":"Practica 2.1","text":""},{"location":"actividad_2.1/#instalacion-y-configuracion-de-servidor-web-nginx","title":"Instalaci\u00f3n y configuraci\u00f3n de servidor web Nginx","text":"<p>Para instalar el servidor nginx en nuestra Debian, lo primero que hacemos es actualizar los repositorios y luego instalamos el paquete necesario:</p> <pre><code>sudo apt update\n\nsudo apt install nginx\n</code></pre> <p>Despu\u00e9s, verificamos que nginx se haya instalado y que est\u00e9 funcionando bien:</p> <pre><code>systemctl status nginx\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"actividad_2.1/#creacion-de-las-carpeta-del-sitio-web","title":"Creaci\u00f3n de las carpeta del sitio web","text":"<p>Al igual que en Apache, todos los archivos que ser\u00e1n parte de un sitio web servido por nginx se organizan en carpetas. Normalmente, estas carpetas est\u00e1n dentro de <code>/var/www</code>.</p> <p>Vamos a crear la carpeta donde estar\u00e1 nuestro sitio web o dominio:</p> <pre><code>sudo mkdir -p /var/www/nombre_web/html\n</code></pre> <p></p> <p>El \"nombre_web\" puede ser lo que quieras, sin espacios.</p> <p>Luego, dentro de esa carpeta <code>html</code>, clona este repositorio:</p> <p>https://github.com/cloudacademy/static-website-example</p> <p></p> <p>Tambi\u00e9n vamos a hacer que el propietario de esa carpeta y todo lo que est\u00e9 dentro sea el usuario <code>www-data</code>, que suele ser el usuario del servicio web:</p> <p><code>sudo chown -R www-data:www-data /var/www/nombre_web/html</code> </p> <p></p> <p>Le daremos los permisos adecuados para que no tengamos problemas de acceso no autorizado al entrar en el sitio web:</p> <p><code>sudo chmod -R 755 /var/www/nombre_web</code> </p> <p></p> <p>Para comprobar que el servidor est\u00e1 funcionando bien y sirviendo p\u00e1ginas correctamente, puedes acceder desde tu cliente a:</p> <p><code>http://IP-maq-virtual</code></p> <p>Deber\u00eda aparecer algo as\u00ed:</p> <p></p> <p>Lo que significar\u00e1 que est\u00e1 correcto hasta ahora.</p>"},{"location":"actividad_2.1/#configuracion-de-servidor-web-nginx","title":"Configuraci\u00f3n de servidor web NGINX","text":"<p>Para que Nginx pueda mostrar el contenido de nuestra web, necesitamos crear un bloque de servidor con las directivas adecuadas. En lugar de modificar el archivo de configuraci\u00f3n predeterminado, vamos a crear uno nuevo en <code>/etc/nginx/sites-available/nombre_web</code>:</p> <pre><code>sudo nano /etc/nginx/sites-available/vuestro_dominio \n</code></pre> <p>El contenido de ese archivo de configuraci\u00f3n ser\u00eda algo como esto:</p> <pre><code>server {\n        listen 80;\n        listen [::]:80;\n        root /ruta/absoluta/archivo/index;\n        index index.html index.htm index.nginx-debian.html;\n        server_name nombre_web;\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre> <p></p> <p>En la directiva <code>root</code>, tienes que poner la ruta completa donde est\u00e9 el archivo <code>index.html</code> de tu p\u00e1gina web, que se encuentra entre los archivos que ya hab\u00e9is descomprimido.</p> <p>Ahora vamos a crear un enlace simb\u00f3lico entre este archivo y el de los sitios habilitados, para que se active autom\u00e1ticamente:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/nombre_web /etc/nginx/sites-enabled/\n</code></pre> <p></p> <p>Y reiniciamos el servidor para aplicar la configuraci\u00f3n:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p>"},{"location":"actividad_2.1/#comprobaciones","title":"Comprobaciones","text":""},{"location":"actividad_2.1/#comprobacion-del-correcto-funcionamiento","title":"Comprobaci\u00f3n del correcto funcionamiento","text":"<p>Como todav\u00eda no tenemos un servidor DNS que traduzca los nombres a IPs, lo vamos a hacer manualmente. Editaremos el archivo <code>/etc/hosts</code> en nuestra m\u00e1quina anfitriona para que asocie la IP de la m\u00e1quina virtual con nuestro <code>server_name</code>.</p> <p>En Linux, este archivo est\u00e1 en <code>/etc/hosts</code>.</p> <p>En Windows lo encontrar\u00e1s en <code>C\\Windows\\System32\\drivers\\etc\\hosts</code>.</p> <p>Ah\u00ed, debemos a\u00f1adir la siguiente l\u00ednea:</p> <p><code>192.168.X.X nombre_web</code></p> <p>Reemplaza \"192.168.X.X\" por la IP de tu m\u00e1quina virtual.</p> <p></p> <p></p>"},{"location":"actividad_2.1/#comprobar-registros-del-servidor","title":"Comprobar registros del servidor","text":"<p>Aseg\u00farate de que las peticiones se est\u00e1n registrando bien en los archivos de logs, tanto las que salen bien como las que fallan:</p> <ul> <li><code>/var/log/nginx/access.log</code>: aqu\u00ed se registra cada solicitud que llega a tu servidor web, a menos que tengas Nginx configurado para otra cosa.</li> </ul> <p></p> <ul> <li><code>/var/log/nginx/error.log</code>: cualquier error que ocurra con Nginx se va a anotar en este archivo.</li> </ul> <p></p>"},{"location":"actividad_2.1/#configurar-servidor-sftp-en-debian","title":"Configurar servidor SFTP en Debian","text":"<p>Primero, vamos a instalarlo desde los repositorios:</p> <pre><code>sudo apt-get update\nsudo apt-get install vsftpd\n</code></pre> <p></p> <p>Ahora, vamos a crear una carpeta en tu home de Debian:</p> <pre><code>mkdir /home/nombre_usuario/ftp\n</code></pre> <p></p> <p>En la configuraci\u00f3n de vsftpd, indicaremos que esta carpeta ser\u00e1 el directorio al que se cambia vsftpd una vez que el usuario se conecta.</p> <p>Luego, vamos a crear los certificados de seguridad necesarios para a\u00f1adir una capa de cifrado a la conexi\u00f3n (algo parecido a HTTPS):</p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem\n</code></pre> <p></p> <p>Una vez hecho esto, pasamos a configurar vsftpd como tal. Usa el editor de texto que prefieras para editar el archivo de configuraci\u00f3n del servicio, por ejemplo con nano:</p> <pre><code>sudo nano /etc/vsftpd.conf\n</code></pre> <p>Primero, busca estas l\u00edneas en el archivo y elim\u00ednalas por completo:</p> <pre><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n</code></pre> <p></p> <p>Despu\u00e9s, a\u00f1ade estas l\u00edneas en su lugar:</p> <pre><code>rsa_cert_file=/etc/ssl/private/vsftpd.pem\nrsa_private_key_file=/etc/ssl/private/vsftpd.pem\nssl_enable=YES\nallow_anon_ssl=NO\nforce_local_data_ssl=YES\nforce_local_logins_ssl=YES\nssl_tlsv1=YES\nssl_sslv2=NO\nssl_sslv3=NO\nrequire_ssl_reuse=NO\nssl_ciphers=HIGH\n\nlocal_root=/home/nombre_usuario/ftp\n</code></pre> <p></p> <p>Finalmente, guarda los cambios y reinicia el servicio para que aplique la nueva configuraci\u00f3n:</p> <pre><code>sudo systemctl restart --now vsftpd\n</code></pre> <p></p> <p>Una vez terminada esta configuraci\u00f3n, ya podr\u00e1s acceder a tu servidor usando un cliente FTP como Filezilla de dos maneras:</p> <ul> <li> <p>Por el puerto 21 (el puerto por defecto de FTP, que es inseguro), pero utilizando certificados para cifrar los datos, haci\u00e9ndolo seguro.</p> </li> <li> <p>Usando el protocolo SFTP, que se dedica al intercambio de datos con una conexi\u00f3n parecida a SSH, usando el puerto 22.</p> </li> </ul> <p>En mi caso utilic\u00e9 el puerto 22 porque el 21 parec\u00eda dar m\u00e1s error.</p> <p>Despu\u00e9s de descargar un cliente FTP en tu ordenador, introduce los datos necesarios para conectarte a tu servidor FTP en Debian:</p> <p></p> <ul> <li> <p>IP de Debian (recuadro rojo)</p> </li> <li> <p>Nombre de usuario de Debian (recuadro verde)</p> </li> <li> <p>Contrase\u00f1a del usuario (recuadro fucsia)</p> </li> <li> <p>Puerto de conexi\u00f3n, que ser\u00e1 el 22 conectando por SFTP (recuadro marr\u00f3n)</p> </li> </ul> <p>Al usar las claves de SSH (como ya hicimos en la Pr\u00e1ctica 1), no necesitas poner la contrase\u00f1a, solo el nombre de usuario.</p> <p>Al conectarte con claves FTP con Conexi\u00f3n r\u00e1pida, te saldr\u00e1 el mismo aviso que cuando te conectaste por primera vez por SSH a Debian. Lo aceptas, ya que no hay ning\u00fan peligro.</p> <p>Te conectar\u00e1s directamente a la carpeta que especificamos en el archivo de configuraci\u00f3n: <code>/home/lara/ftp</code>.</p> <p></p> <p>Una vez conectado, en el lado izquierdo de la pantalla (tu ordenador) buscas una imagen cualquiera (por ejemplo). En el lado derecho (el servidor), busca la carpeta donde quieres subir el archivo. Con un doble clic o haciendo clic derecho &gt; subir, lo transfieres al servidor.</p> <p>Recuerda que tu sitio web debe estar en la carpeta <code>/var/www</code> y es necesario darle los permisos adecuados, como hicimos con el otro sitio web.</p>"},{"location":"actividad_2.1/#https","title":"HTTPS","text":"<p>En esta parte vamos a a\u00f1adir una capa extra de seguridad a nuestro servidor. Vamos a hacer que todos los sitios web que tengamos usen certificados SSL y que se acceda a ellos a trav\u00e9s de HTTPS.</p> <p>Para hacerlo, y como prueba, vamos a generar unos certificados autofirmados. Luego, en el archivo de configuraci\u00f3n de nuestros hosts virtuales (los sitios web que ya configuramos), cambiaremos los par\u00e1metros que hagan falta.</p> <p>Puedes buscar en Internet para guiarte y conseguir el resultado que necesitas.</p> <p>En mi caso, me ayud\u00e9 de internet y la ayuda de unos amigos programadores.</p>"},{"location":"actividad_2.1/#redireccion-http-a-https","title":"Redirecci\u00f3n HTTP a HTTPS","text":"<p>Cuando hayas terminado de habilitar HTTPS en tus sitios web, puedes pasar a esta tarea.</p> <p>F\u00edjate que con la configuraci\u00f3n actual, tu sitio web es accesible de dos formas al mismo tiempo: por el puerto 80 (HTTP, que es inseguro) y por el puerto 443 (HTTPS, que es seguro). Como queremos dejar todo bien configurado y sin posibles fallos de seguridad, el objetivo es que, si un usuario accede a tu sitio por el puerto 80 (HTTP), autom\u00e1ticamente se le redirija a HTTPS, en el puerto 443, por seguridad.</p> <p>Busca la informaci\u00f3n necesaria para hacer esta redirecci\u00f3n autom\u00e1tica ajustando tus archivos de configuraci\u00f3n de hosts virtuales.</p> <p>De nuevo, personalmente me ayud\u00e9 de internet y unos amigos programadores.</p> <p>Para finalmente, terminarlo:</p> <p></p> <p></p>"},{"location":"actividad_2.1/#cuestiones-finales","title":"Cuestiones finales","text":"<p>\u00bfQu\u00e9 pasa si no hago el link simb\u00f3lico entre <code>sites-available</code> y <code>sites-enabled</code> de mi sitio web?</p> <p>Si no haces el enlace simb\u00f3lico entre <code>sites-available</code> y <code>sites-enabled</code>, tu sitio web no estar\u00e1 activo y Nginx no lo reconocer\u00e1. Esto significa que no podr\u00e1s acceder a tu sitio a trav\u00e9s de la web, ya que Nginx no lo servir\u00e1. As\u00ed que es un paso importante para que tu sitio est\u00e9 disponible.</p> <p>\u00bfQu\u00e9 pasa si no le doy los permisos adecuados a <code>/var/www/nombre_web</code>?</p> <p>Si no le das los permisos adecuados a <code>/var/www/nombre_web</code>, tu servidor web no podr\u00e1 acceder a los archivos de tu sitio. Esto puede causar errores al intentar cargar la p\u00e1gina, y los usuarios ver\u00e1n mensajes de acceso denegado. En resumen, tu sitio no funcionar\u00e1 correctamente.</p>"},{"location":"actividad_2.2/","title":"Practica 2.2","text":""},{"location":"actividad_2.2/#autenticacion-en-nginx","title":"Autenticaci\u00f3n en Nginx","text":""},{"location":"actividad_2.2/#paquetes-necesarios","title":"Paquetes necesarios","text":"<p>Podemos usar la herramienta openssl para crear contrase\u00f1as.</p> <p>Se puede comprobar si la tenemos instalada con el siguiente comando:</p> <pre><code>dpkg -l | grep openssl\n</code></pre> <p>En mi caso, estaba instalado:</p> <p></p>"},{"location":"actividad_2.2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Crearemos un archivo oculto llamado \u201c.htpasswd\u201d en el directorio de configuraci\u00f3n <code>/etc/nginx</code> donde guardar nuestros usuarios y contrase\u00f1as (la -c es para crear el archivo): </p> <pre><code>sudo sh -c \"echo -n 'vuestro_nombre:' &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Y a continuaci\u00f3n creamos el password cifrado para el usuario:</p> <pre><code>sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Se pueden crear tantos usuarios como haga falta. Para este ejercicio, yo he creado dos, uno para mi nombre, y otro para mi apellido.</p> <p>Podemos comprobar que los usuarios y contrase\u00f1as est\u00e1n cifrados:</p> <pre><code>cat /etc/nginx/.htpasswd\n</code></pre> <p></p>"},{"location":"actividad_2.2/#configurando-el-servidor-nginx-para-usar-autenticacion-basica","title":"Configurando el servidor Nginx para usar autenticaci\u00f3n b\u00e1sica","text":"<p>Para poder proteger nuestra web teniendo que introducir el usuario y contrase\u00f1a, debemos modificar nuestro archivo en:</p> <pre><code>sudo nano /etc/nginx/sites-available/nombre_web\n</code></pre> <p></p> <p>Y a\u00f1adir <code>auth_basic</code> dentro de location, junto a <code>auth_basic_user_file</code> y el fichero que hemos creado anteriormente para las contrase\u00f1as.</p> <p></p> <p>Tras ello, debemos reiniciar el servicio para ue se apliquen los cambios y podamos comprobarlo:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p>"},{"location":"actividad_2.2/#probando-la-nueva-configuracion","title":"Probando la nueva configuraci\u00f3n","text":"<p>Al intentar ahora entrar a la web desde mi m\u00e1quina, pide un usuario y contrase\u00f1a:</p> <p></p> <p>Si se cancela, se denega el acceso a la misma:</p> <p></p> <p>Para la Tarea 1 se ha probado con un usuario bueno y otro err\u00f3neo, y comprobando los logs de <code>access.log</code> se pueden ver los logins de los que han podido entrar con \u00e9xito:</p> <p></p> <p>Y si comprobamos los logs de <code>error.log</code> podemos ver los que han fallado:</p> <p></p> <p>A continuaci\u00f3n se pide el denegar acceso a solo cierta parte de la p\u00e1gina, pero como nuestras webs es\u00e1n faltas del mencionado <code>contact.html</code>, he escrito c\u00f3mo se ver\u00eda si quisi\u00e9semos denegar acceso al mismo incluso si en mi p\u00e1gina no hace nada:</p> <p></p>"},{"location":"actividad_2.2/#combinacion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP","text":"<p>Tambi\u00e9n podemos usar las restricciones para denegar el acceso a partir de las IP. con la ayuda de <code>allow</code> y <code>deny</code>. Y se pueden perfectamente combinar las IP con la necesidad de identificaci\u00f3n de usuario.</p> <p>En la Tarea 1 de esta secci\u00f3n se ped\u00eda denegar el acceso a la IP de nuestra m\u00e1quina anfitriona:</p> <p></p> <p>Y si comprobamos tras guardar y reiniciar, deber\u00eda darnos otro error:</p> <p></p> <p>El cu\u00e1l tambi\u00e9n podemos comprobar a trav\u00e9s del <code>error.log</code>:</p> <p></p> <p>Como se mencion\u00f3 anteriormente, tambi\u00e9n se puede configurar para que se necesite acceso desde cierta IP o con la autentificaci\u00f3n de usuario, y lo podemos hacer as\u00ed:</p> <p></p> <p>Al probar entrar a la p\u00e1gina desde mi m\u00e1quina, se comprueba que esta vez me deja entrar, por darme derecho a la IP de que puedo acceder:</p> <p></p>"},{"location":"actividad_2.2/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.2/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, equivoc\u00e1ndome al poner el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n    deny  all;\n    auth_basic \"Cuesti\u00f3n final 1\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: Supuestamente no deber\u00eda dejar entrar, ya que pide tanto la IP como el usuario correcto.</p>"},{"location":"actividad_2.2/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  all;\n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 2: The revenge\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: Esta vez se puede acceder, porque esa IP en concreto tiene el permiso para entrar Y el usuario se ha introducido bien, incluso con el <code>deny all</code> de por medio.</p>"},{"location":"actividad_2.2/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;    \n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Respuesta: No podr\u00edamos acceder desde esa IP porque est\u00e1 denegada. Esa prohibici\u00f3n tiene prioridad sobre el <code>satisfy any</code>.</p>"},{"location":"actividad_2.2/#cuestion-4","title":"Cuesti\u00f3n 4","text":"<p>A lo mejor no sab\u00e9is que tengo una web para documentar todas mis excursiones espaciales con Jeff, es esta: Jeff Bezos y yo.</p> <p>Supongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n b\u00e1sica a la URL:<code>Proyectos</code></p> <p>Completa la configuraci\u00f3n para conseguirlo:</p> <p>Ejemplo sin el c\u00f3digo</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre> <p>C\u00f3digo modificado</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n        location /Proyectos {\n                auth_basic \"\u00c1rea restringida\";\n                auth_basic_user_file /etc/nginx/.htpasswd;\n                try_files $uri $uri/ =404;\n        }\n    }\n</code></pre>"},{"location":"actividad_2.3/","title":"Practica 2.3","text":""},{"location":"actividad_2.3/#proxy-inverso-con-nginx","title":"Proxy inverso con Nginx","text":""},{"location":"actividad_2.3/#configuraciones","title":"Configuraciones","text":"<p>Nginx servidor web</p> <p>Vamos a clonar nuestra primera m\u00e1quina de Debian para poder tener dos, siguiendo estas pautas:</p> <ul> <li>Uno servir\u00e1 para la web que ya hemos montado en la pr\u00e1ctica anterior (Actividad 2.1).</li> <li>La nueva m\u00e1quina clonada se usar\u00e1 para el proxy inverso.</li> <li>Realizaremos las peticiones HTTP desde el navegador de nuestra m\u00e1quina f\u00edsica/anfitri\u00f3n al proxy clonado, que luego redirigir\u00e1 al servidor web original.</li> </ul> <pre><code>\u00a1OJO! Al clonar las m\u00e1quinas virtuales porque hay que darle a crear una nueva MAC, de lo contrario no tendr\u00e9is IP en esa m\u00e1quina.\n</code></pre> <p></p> <p></p> <p>Para diferenciarlo mejor, vamos a modificar los servidores para que cada uno haga la petici\u00f3n desde un puerto diferente.</p> <ol> <li> <p>Primero, vamos a cambiar el nombre antiguo del servidor web original por el de <code>webserver</code>, y eso implica:</p> </li> <li> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles para Nginx.</p> </li> <li> <p>Cambiar el nombre del sitio web dentro de este archivo de configuraci\u00f3n donde haga falta.</p> </li> </ol> <p></p> <ul> <li>No os olvid\u00e9is de eliminar el link simb\u00f3lico antiguo con el comando <code>unlink nombre_del_link</code> dentro de la carpeta <code>sites-enabled</code> y crear el nuevo para el nuevo nombre de archivo.</li> </ul> <p></p> <p></p> <p></p> <ol> <li>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que el servidor escuche en el puerto 80, cambiadlo al 8080.</li> </ol> <p></p> <ol> <li>Reiniciamos Nginx.</li> </ol> <p></p> <p>Nginx proxy inverso</p> <p>Ahora, cuando intentamos acceder a <code>http://ejemplo-proxy</code> (o el nombre que tuvier\u00e1is de vuestra web de las pr\u00e1cticas anteriores), en realidad estaremos accediendo al proxy, que nos redirigir\u00e1 a <code>http://webserver:8080</code>, el servidor web que acabamos de configurar para que escuche con ese nombre en el puerto 8080. Pero para ello debemos seguir los siguientes pasos:</p> <ul> <li> <p>Crear un archivo de configuraci\u00f3n en sites-available con el nombre ejemplo-proxy (o el que tuvier\u00e1is vosotros).</p> </li> <li> <p>Este archivo de configuraci\u00f3n ser\u00e1 m\u00e1s simple, tendr\u00e1 la siguiente forma.</p> </li> </ul> <pre><code>server { \n    listen __; \n    server_name ____________; \n    location / { \n    proxy_pass http://_________:____; \n    } \n} \n</code></pre> <p>Donde, mirando el diagrama de red y teniendo en cuenta la configuraci\u00f3n hecha hasta ahora, deb\u00e9is completar:</p> <ul> <li> <p>El puerto donde est\u00e1 escuchando el proxy inverso</p> </li> <li> <p>El nombre de vuestro dominio o sitio web original al que accedemos en el proxy</p> </li> <li> <p>La directiva <code>proxy_pass</code> indica a d\u00f3nde se van a redirigir las peticiones, esto es, al servidor web. Por tanto, deb\u00e9is poner la IP y n\u00famero de puerto adecuados de vuestro sitio web configurado en el apartado anterior.</p> </li> <li> <p>Crear el link simb\u00f3lico pertinente</p> </li> </ul> <p></p> <p></p> <p>\u00a1OJO! En mi caso en concreto he tenido que poner el link en el <code>proxy_pass</code> sin el <code>8080</code> al final, de otra manera no me llegaba a funcionar.</p> <pre><code>Deb\u00e9is modificar el archivo host que configurast\u00e9is en la pr\u00e1ctica 2.1. Si mir\u00e1is el diagrama de red, ahora el nombre de vuestro sitio web se corresponder\u00e1 con la IP de la nueva m\u00e1quina clon que hace de proxy. Ser\u00e1 \u00e9sta la encargada de redirigirnos autom\u00e1ticamente al verdadero sitio web.\n</code></pre> <p></p>"},{"location":"actividad_2.3/#comprobaciones","title":"Comprobaciones","text":"<p>Deber\u00edais poder acceder a vuestro sitio web sin problemas.</p> <ul> <li> <p>Comprobad en los access.log de los dos servidores que llega la petici\u00f3n</p> </li> <li> <p>Comprobad adem\u00e1s la petici\u00f3n y respuesta con las herramientas de desarrollador de Firefox en Xubuntu. Pulsando F12 en el navegador os aparecer\u00e1n estas herramientas.</p> </li> </ul> <p></p> <p></p> <p>Deb\u00e9is entrar en Red &gt; luego donde se puede ver la respuesta &gt; y ver la respuesta HTTP como petici\u00f3n GET HTTP (200 OK).</p> <p>Tambi\u00e9n deber\u00edan aparecer las cabeceras, de las cuales podemos a\u00f1adir algunas nosotros.</p> <p>A\u00f1adiendo cabeceras</p> <pre><code>Es importante desactivar el cach\u00e9 para hacer las pruebas siguientes.\n</code></pre> <p>Como una manera extra de comprobar que todo va bien, podemos a\u00f1adir las cabeceras de la siguiente manera:</p> <ul> <li>Para a\u00f1adir cabeceras, en el archivo de configuraci\u00f3n del sitio web debemos a\u00f1adir dentro del bloque <code>location / { \u2026 }</code> debemos a\u00f1adir la directiva: </li> </ul> <pre><code>add_header Host nombre_del_host;\n</code></pre> <ol> <li>A\u00f1adimos primero esta cabecera solo en el archivo de configuraci\u00f3n del proxy inverso. El Nombre_del_host ser\u00e1 Proxy_inverso_vuestronombre.</li> </ol> <p></p> <ol> <li> <p>Reiniciamos Nginx.</p> </li> <li> <p>Comprobamos que podemos acceder al sitio web sin problemas.</p> </li> <li> <p>Con las herramientas de desarrollador comprobamos que el nuevo header aparece en la respuesta.</p> </li> <li> <p>Luego hacemos lo mismo pero con el archivo del servidor web original. Esta vez el <code>Nombre_del_host</code> ser\u00e1 <code>servidor_web_vuestronombre</code>.</p> </li> </ol> <p>Si todo est\u00e1 bien, ahora deber\u00edan aparecer los dos.</p> <p></p>"},{"location":"actividad_2.4/","title":"Practica 2.4","text":""},{"location":"actividad_2.4/#balanceo-de-carga-con-proxy-inverso-en-nginx","title":"Balanceo de carga con proxy inverso en Nginx","text":""},{"location":"actividad_2.4/#configuraciones","title":"Configuraciones","text":"<pre><code>\u00a1OJO! Como detalle a tener en cuenta, deberemos desactivar los sitios web de las tareas anteriores para que no den problemas.\n\nDentro de la carpeta `/etc/nginx/sites-enabled` debemos ejecutar `unlink nombre_archivo` para cada uno de los archivos de los sitios web que tenemos.\n</code></pre>"},{"location":"actividad_2.4/#nginx-servidor-web-1","title":"Nginx Servidor Web 1","text":"<p>Debemos configurar este servidor web para que sirva el siguiente <code>index.html</code> que deb\u00e9is crear dentro de la carpeta <code>/var/www/webserver1/html</code>:</p> <p></p> <ul> <li> <p>El nombre del sitio web que se debe utilizar en los archivos (sites-available, etc) para Nginx es <code>webserver1</code>, igual que en el resto de configuraciones.</p> </li> <li> <p>El sitio web debe escuchar al puerto 8080.</p> </li> <li> <p>Se debe a\u00f1adir una cabecera que se llame <code>Serv_Web1_vuestronombre</code>.</p> </li> </ul> <p></p>"},{"location":"actividad_2.4/#nginx-servidor-web-2","title":"Nginx Servidor Web 2","text":"<p>Se debe clonar en la m\u00e1quina Debian, del servidor web 1.</p> <p></p> <p>Se debe hacer una configuraci\u00f3n id\u00e9ntica, pero cambiando los nombres de <code>webserver1</code> por <code>webserver2</code> (inclu\u00eddo el index.html), y el nombre de la cabecera ser\u00e1 <code>Serv_Web2_vuestronombre</code>.</p> <pre><code>\u00a1OJO! Es importante que no quede ninguna referencia al webserver1, o podr\u00eda haber problemas.\n</code></pre>"},{"location":"actividad_2.4/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>Ya que tenemos los servidores web, lo que nos quedar\u00e1 es configurar el proxy inverso.</p> <ul> <li>En sites-available vamos a crear el archivo de configuraci\u00f3n con el nombre <code>balanceo</code>.</li> </ul> <p>Y el archivo tendr\u00e1 el siguiente formato:</p> <pre><code>    upstream backend_hosts {\n                random;\n                server ________:____;\n                server ________:____;\n    }\n            server {\n                listen 80;\n                server_name ________;      \n                location / {\n                    proxy_pass http://backend_hosts;\n                }\n            }\n</code></pre> <ul> <li> <p>El bloque upstream \u2192 son los servidores entre los que se va a repartir la carga, que son los dos que hemos configurado anteriormente.</p> </li> <li> <p>Si mir\u00e1is el diagrama y ten\u00e9is en cuenta la configuraci\u00f3n que hab\u00e9is hecho hasta ahora, aqu\u00ed deber\u00e9is colocar la IP de cada servidor, as\u00ed como el puerto donde est\u00e1 escuchando las peticiones web.</p> </li> <li> <p>A este grupo de servidores le ponemos un nombre, que es <code>backend_hosts</code>.</p> </li> <li> <p>Pondremos random porque es lo m\u00e1s f\u00e1cil para comprobar que todo funciona bien en la pr\u00e1ctica, pero hay diferentes formas de repartir la carga (las peticiones HTTP). </p> </li> </ul> <p></p>"},{"location":"actividad_2.4/#comprobaciones","title":"Comprobaciones","text":"<p>Se deber\u00eda poder acceder al sitio web sin problemas, recordando que se debe desactivar el cach\u00e9.</p> <p></p> <p></p> <p>Si refrescamos, el servidor es aleatorio, y si se desactiva el servidor 1, se ir\u00e1 al 2, igual que si desactivamos el servidor 2, se ir\u00e1 al 1.</p>"},{"location":"actividad_2.4/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.4/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Busca informaci\u00f3n de qu\u00e9 otros m\u00e9todos de balanceo se pueden aplicar con Nginx y describe al menos 3 de ellos.</p> <ul> <li> <p><code>Round Robin</code>: Asigna las solicitudes en un ciclo uniforme entre todos los servidores, ideal para ambientes de carga similar\u200b.</p> </li> <li> <p><code>Least Connections</code>: Redirige las solicitudes al servidor con menos conexiones activas, equilibrando cargas en sistemas con tr\u00e1fico variable.</p> </li> <li> <p><code>IP Hash</code>: Env\u00eda solicitudes del mismo cliente al mismo servidor, manteniendo la sesi\u00f3n y datos consistentes, \u00fatil para aplicaciones como e-commerce.</p> </li> </ul>"},{"location":"actividad_2.4/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Si quiero a\u00f1adir 2 servidores web m\u00e1s al balanceo de carga, describe detalladamente qu\u00e9 configuraci\u00f3n habr\u00eda que a\u00f1adir y d\u00f3nde.</p> <ul> <li>Si tenemos ya configurado, lo \u00fanico que debemos hacer es a\u00f1adir los servidores extra en el bloque de <code>upstream</code>.</li> </ul> <pre><code>upstream webserverejemplo {\n    ...;\n    server &lt;host_servidor_1&gt;:&lt;puerto_servidor_1&gt;;\n    server &lt;host_servidor_2&gt;:&lt;puerto_servidor_2&gt;;\n}\n</code></pre>"},{"location":"actividad_2.4/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Describe todos los pasos que deber\u00edamos seguir y configurar para realizar el balanceo de carga con una de las webs de pr\u00e1cticas anteriores.</p> <p>Indicad la configuraci\u00f3n de todas las m\u00e1quinas (webservers, proxy...) y de sus servicios.</p> <ul> <li> <p>Tal y como hemos hecho con este ejercicio, se deber\u00e1n tener al menos 3 m\u00e1quinas virtuales. El servidor web original, el servidor 2 clonado del original, y el proxy inverso.</p> </li> <li> <p>Para la configuraci\u00f3n del servidor web, debemos crear un archivo en el directorio <code>/etc/nginx/sites-available</code>, y debemos elegir un nombre. Para este ejemplo, se llamar\u00e1 <code>webtest</code> y debe quedar as\u00ed:</p> </li> </ul> <pre><code>/etc/nginx/sites-available/webtest\n\nserver {\n    listen 8080;\n    server_name webtest.local;\n\n    location / {\n        root /var/www/webtest/html;\n        index index.html;\n\n        add_header webtest_lara webtest;\n    }\n}\n</code></pre> <ul> <li>Tras tener configurado el archivo, creamos el enlace:</li> </ul> <pre><code>sudo ln -s /etc/nginx/sites-available/webtest /etc/nginx/sites-enabled/\n</code></pre> <ul> <li>Y lo reiniciamos:</li> </ul> <pre><code>sudo systemctl restart nginx\n</code></pre> <ul> <li>Para la configuraci\u00f3n del servidor clonado, solo se tiene que clonar el servidor anterior, pero cambiando el antiguo <code>server_name</code> para que no haya errores.</li> </ul> <pre><code>/etc/nginx/sites-available/webtest\n\nserver {\n    listen 8080;\n    server_name webtest2.local;\n\n    location / {\n        root /var/www/webtest/html;\n        index index.html;\n\n        add_header webtest2_lara webtest;\n    }\n}\n</code></pre> <ul> <li>Para la configuraci\u00f3n del proxy, lo haremos igual que en la pr\u00e1ctica en s\u00ed. Creamos un archivo que deber\u00eda llevar esta configuraci\u00f3n:</li> </ul> <pre><code>/etc/nginx/sites-available/webtest-proxy\n\n    upstream webtest {\n                random;\n                server webtest.local:8080;\n                server webtest2.local:8080;\n    }\n            server {\n                listen 80;\n                server_name webtest.local;      \n                location / {\n                    proxy_pass http://webtest;\n                }\n            }\n</code></pre> <ul> <li>No se debe olvidar el crear los enlaces pertinentes con el comando de siempre:</li> </ul> <pre><code>sudo ln -s /etc/nginx/sites-available/webtest-proxy /etc/nginx/sites-enabled/\n</code></pre> <ul> <li>Por \u00faltimo, se reinicia de nuevo:</li> </ul> <pre><code>sudo systemctl restart nginx\n</code></pre> <ul> <li>Como \u00faltimo paso, a\u00f1adimos al archivo hosts de nuestro pc la IP del proxy para poder probarlo, en Windows, la localizaci\u00f3n ser\u00eda:</li> </ul> <pre><code>C:\\Windows\\System32\\drivers\\etc\\hosts\n\n...\nip-proxy webtest.local\n</code></pre> <ul> <li>En Linux, la localizaci\u00f3n estar\u00eda en:</li> </ul> <pre><code>/etc/hosts\n\n...\nip-proxy webtest.local\n</code></pre>"},{"location":"actividad_2.5/","title":"Practica 2.5","text":""},{"location":"actividad_2.5/#proxy-inverso-y-balanceo-de-carga-con-ssl-en-nginx","title":"Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"actividad_2.5/#configuraciones","title":"Configuraciones","text":"<p>Partiendo de la configuraci\u00f3n exacta de la pr\u00e1ctica anterior, vamos a a\u00f1adir la configuraci\u00f3n SSL para el cifrado del Proxy Inverso.</p>"},{"location":"actividad_2.5/#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado","text":"<p>Nosotros no usaremos un CA de confianza, ya que no estamos publicando en internet Y los certificados son de pago.</p> <p>Nosotros crearemos el nuestro propio para simular el escenario, por lo que la primera vez que accedamos el sitio web, saldr\u00e1 una advertencia.</p> <p>En primer lugar, tenemos que crear el sguiente directorio:</p> <p><code>/etc/nginx/ssl</code></p> <p></p> <p>Luego, podemos crear el certificado con un \u00fanico comando:</p> <p><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/server.key -out /etc/nginx/ssl/server.crt</code></p> <p></p> <p>Nos preguntar\u00e1 el introducir una serie de par\u00e1metros. Se deben introducir los par\u00e1metros de la siguiente imagen, a excepci\u00f3n del \u201cOrganizational Unit Name\u201d. Ah\u00ed deber\u00e9is poner <code>2DAW \u2013 DEAW - Vuestronombre</code>.</p> <p></p>"},{"location":"actividad_2.5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el proxy inverso","text":"<p>De la pr\u00e1ctica anterior, ya deber\u00edas tener en el directorio <code>/etc/nginx/sites-available</code> un archivo de configuraci\u00f3n llamado \u201cbalanceo\u201d. Aqu\u00ed es donde vamos a configurar el acceso al sitio web para que funcione con SSL (HTTPS).</p> <p>Dentro del bloque <code>server {\u2026}</code>, cambia el puerto de escucha (<code>listen 80</code>) por lo que ves en la imagen de abajo. Adem\u00e1s, a\u00f1ade las siguientes l\u00edneas de configuraci\u00f3n para que quede as\u00ed:</p> <p></p> <p>Recordad el reiniciar el servicio de Nginx como de costumbre tras el cambio.</p>"},{"location":"actividad_2.5/#comprobaciones","title":"Comprobaciones","text":"<ul> <li> <p>Si ahora accedes a <code>https://balanceo.local</code>, ver\u00e1s un aviso de seguridad porque nuestro certificado es autofirmado, como mencionamos antes.</p> </li> <li> <p>Si agregas una excepci\u00f3n, podr\u00e1s entrar al sitio, y al recargar la p\u00e1gina varias veces con F5, ver\u00e1s que el balanceo de carga funciona bien usando HTTPS.</p> </li> <li> <p>Para confirmar que los datos del certificado son los tuyos, haz clic en el candado en la barra de b\u00fasqueda:</p> </li> </ul> <p></p> <p></p> <p></p>"},{"location":"actividad_2.5/#redireccion-forzosa-a-https","title":"Redirecci\u00f3n forzosa a HTTPS","text":"<p>Para que s\u00ed o s\u00ed nos fuerce a usar HTTPS, haremos una configuraci\u00f3n adicional.</p> <p>A\u00f1adiremos un nuevo bloque 'server' separado del otro, en el archivo de configuraci\u00f3n de 'balanceo'.</p> <p>Debe quedar algo as\u00ed:</p> <p></p> <p>Lo que estamos haciendo es que cuando se reciba una petici\u00f3n HTTP (puerto 80) en <code>http://balanceo.local</code>, se redirija a <code>https://balanceo.local</code> (HTTPS).</p> <p>La tarea extra ha consistido en:</p> <ul> <li> <p>Eliminar del otro bloque <code>server{...}</code> las l\u00edneas que hac\u00edan referencia al puerto 80.</p> </li> <li> <p>Hemos reiniciado el servicio.</p> </li> <li> <p>Se ha comprobado que ahora fuerza siempre la redirecci\u00f3n a HTTPS.</p> </li> <li> <p>Y se ha comprobado que cuando realizamos una petici\u00f3n en el archivo de log <code>http_access.log</code> aparece la redirecci\u00f3n 301 y que, de la misma manera, aparece una petici\u00f3n GET en <code>https_access.log</code>.</p> </li> </ul> <p></p>"},{"location":"actividad_2.5/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"actividad_2.5/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error del tipo <code>This site can't provide a secure connection, ERR_SSL_PROTOCOL_ERROR</code>.</p> <p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\n    listen 443;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n</code></pre> <p>En el primer <code>listen 443</code> ha faltado poner el <code>ssl</code>. Deber\u00eda quedar como:</p> <p><code>listen 443 ssl;</code></p>"},{"location":"actividad_2.5/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Imaginad que intentamos acceder a nuestro sitio web HTTPS y nos encontramos con el siguiente error, luego, investigad qu\u00e9 est\u00e1 pasando y como se ha de solucionar.</p> <p></p> <p>El error <code>NET::ERR_CERT_REVOKED</code> en una conexi\u00f3n HTTPS significa que el certificado del sitio ha sido revocado por la entidad certificadora, lo que indica que ya no es confiable. Esto puede suceder si el certificado fue comprometido, emitido por error, o revocado a petici\u00f3n del propietario. Para solucionarlo, el administrador del sitio debe reemplazar el certificado por uno nuevo y v\u00e1lido; como usuario, no puedes evitar el error hasta que el sitio lo corrija.</p>"},{"location":"actividad_3.1/","title":"Practica 3.1 Instalaci\u00f3n de Tomcat","text":""},{"location":"actividad_3.1/#instalacion-de-tomcat","title":"Instalaci\u00f3n de Tomcat","text":"<p>Realizaremos la instalaci\u00f3n del servidor de aplicaciones Tomcat 10, en una m\u00e1quina virtual corriendo Debian 11 Bullseye.</p> <p>En mi caso, he seguido el siguiente tutorial para instalarlo con el administrador de paquetes.</p>"},{"location":"actividad_3.1/#despliegue-manual-mediante-la-gui-de-administracion","title":"Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Para esta pr\u00e1ctica podemos descargar el WAR aqu\u00ed.</p> <p>Realizaremos el despliegue manual de una aplicaci\u00f3n ya previamente empaquetada en formato WAR. Para ello:</p> <ul> <li> <p>Nos logueamos con el usuario previamente creado.</p> </li> <li> <p>Buscamos la secci\u00f3n que nos permite desplegar un WAR manualmente, seleccionamos nuestro archivo y lo desplegamos.</p> </li> </ul> <p></p> <p></p>"},{"location":"actividad_3.1/#despliegue-con-maven","title":"Despliegue con Maven","text":""},{"location":"actividad_3.1/#instalacion-de-maven","title":"Instalaci\u00f3n de Maven","text":"<p>Hay dos maneras de instalarlo, con el administrador de paquetes o manualmente. Yo personalmente voy a explicar c\u00f3mo instalarlo con el administrador de paquetes siguiendo estos sencillos pasos:</p> <p>Actualizamos los repositorios:</p> <pre><code>sudo apt update\n</code></pre> <p>Instalamos Maven:</p> <pre><code>sudo apt install maven\n</code></pre> <p>Comprobamos que funciona bien:</p> <pre><code>mvn --v\n</code></pre> <p></p>"},{"location":"actividad_3.1/#configuracion-de-maven","title":"Configuraci\u00f3n de Maven","text":"<p>Necesitamos realizar la configuraci\u00f3n adecuada para Maven, modificando los siguientes archivos:</p> <p>Modificamos el archivo <code>/etc/tomcat9/tomcat-users.xml</code> acorde a nuestras necesidades (los nombres de usuario y contrase\u00f1a deber\u00e1n ser los que elij\u00e1is para vosotros), debe quedar as\u00ed:</p> <p></p> <p>Luego, editamos el archivo <code>/etc/maven/settings.xml</code> para indicarle a Maven, un identificador para el servidor sobre el que vamos a desplegar (no es m\u00e1s que un nombre, ponedle el nombre que consider\u00e9is), as\u00ed como las credenciales. Todo esto se har\u00e1 dentro del bloque servers del XML:</p> <p></p>"},{"location":"actividad_3.1/#configurar-un-proyecto-de-java-maven","title":"Configurar un proyecto de Java Maven","text":"<p>Como para este paso necesitamos un proyecto de Java que utilice Maven, usaremos un repositorio para la pr\u00e1ctica y pondremos el patch-1 para cubrir de paso una tarea que se preguntaba m\u00e1s delante:</p> <pre><code>git clone https://github.com/cameronmcnz/rock-paper-scissors.git &amp;&amp; cd rock-paper-scissors &amp;&amp; git checkout patch-1\n</code></pre> <p>Despues de hacerlo, debemos modificar el <code>POM</code> del proyecto para que haga referencia a que el despliegue se realice con el plugin de Maven para Tomcat.</p> <p></p> <p>Este es el bloque a a\u00f1adir:</p> <pre><code>&lt;build&gt;\n        &lt;finalName&gt;war-deploy&lt;/finalName&gt; \n\n\n        &lt;plugins&gt; \n        &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; \n\n\n            &lt;server&gt;Tomcat.P.3.1&lt;/server&gt; \n\n\n            &lt;path&gt;/myapp&lt;/path&gt; \n\n\n        &lt;/configuration&gt;\n        &lt;/plugin&gt;\n        &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>"},{"location":"actividad_3.1/#despliegue","title":"Despliegue","text":"<p>Teniendo ya todo listo para realizar despliegues, ahora crearemos una aplicaci\u00f3n Java de prueba para ver si podemos desplegarla sobre la arquitectura que hemos montado. Para ello utilizamos el comando:</p> <pre><code>mvn archetype:generate -DgroupId=lara -DartifactId=war-deploy -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false\n</code></pre> <p>Tras generar esta aplicaci\u00f3n, usaremos un comando final para desplegar y comprobar que se ha buildeado correctamente:</p> <pre><code>sudo mvn tomcat7:deploy\n</code></pre> <p></p> <p>Y, accediendo a trav\u00e9s de la GUI, debemos ver que la aplicaci\u00f3n est\u00e1 desplegado y que podemos acceder a ella perfectamente:</p> <p></p> <p></p>"},{"location":"actividad_3.1/#cuestiones","title":"Cuestiones","text":"<pre><code>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas.\n\nEn principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averig\u00fcar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?\n</code></pre> <p>Se espera que, al instalar Tomcat, solo root y el usuario que lo ejecuta puedan acceder a esos archivos, para proteger las contrase\u00f1as, igual que pasa con el archivo /etc/shadow, que solo los administradores pueden ver.</p>"},{"location":"actividad_3.2/","title":"Practica 3.2 Despliegue de aplicaciones con Node Express","text":""},{"location":"actividad_3.2/#ojo","title":"\u00a1OJO!","text":"<p>Debemos comprobar que el servidor de Tomcat que hemos instalado anteriormente est\u00e1 desactivado, o dar\u00e1 problemas:</p> <p><code>sudo systemctl status tomcat10</code></p> <p>Y en caso de que est\u00e9 activo, se para:</p> <p><code>sudo systemctl stop tomcat10</code></p>"},{"location":"actividad_3.2/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Primero, instalaremos Node.js y Express en Debian 11. Luego, crearemos un archivo <code>.js</code> de prueba para asegurarnos de que el despliegue funciona.</p> <p>Personalmente he seguido este [tutorial] (https://web.archive.org/web/20240420163631/https://unixcop.com/how-to-install-expressjs-on-debian-11/) para instalar Node.js.</p> <p>Para Express, recuerda acceder a <code>http://IP-maq-virtual:3000</code> desde tu m\u00e1quina local, usando la IP de tu m\u00e1quina virtual, en lugar de <code>http://localhost:3000</code>.</p> <p>Recordad parar el servidor (CTRL+C) al acabar la pr\u00e1ctica.</p> <p> </p>"},{"location":"actividad_3.2/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Vamos a desplegar una app de terceros como ejemplo. Es un prototipo de predicci\u00f3n meteorol\u00f3gica que est\u00e1 en este repositorio de GitHub.</p> <p>Lo primero es clonar el repositorio siguiendo las instrucciones que ah\u00ed se indican:</p> <pre><code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application\n</code></pre> <p>Nos movemos al nuevo directorio:</p> <pre><code>cd Shopping-Cart-Application/\n</code></pre> <p></p> <p>Instalamos librer\u00edas necesarias:</p> <pre><code>npm install\n</code></pre> <p>Y por \u00faltimo la iniciamos:</p> <pre><code>npm run start\n</code></pre> <p>Dar\u00e1 un error de este tipo al intentar arrancar:</p> <pre><code>sh: 1: nodemon: not found\n</code></pre> <p></p> <p>Para solucionar el problema, instalamos nodemon desde consola y listo.</p> <p> </p>"},{"location":"actividad_3.2/#cuestiones","title":"Cuestiones","text":"<p>Cuando ejecut\u00e1is el comando npm run start, lo que est\u00e1is haciendo es ejecutar un script:</p> <pre><code>- \u00bfDonde podemos ver que script se est\u00e1 ejecutando?\n</code></pre> <p>En el archivo <code>package.json</code>, dentro de la secci\u00f3n <code>\"scripts\"</code>. Ah\u00ed se define qu\u00e9 hace el comando <code>npm run start</code>.</p> <pre><code>- \u00bfQu\u00e9 comando est\u00e1 ejecutando?\n</code></pre> <p>Depende de lo que est\u00e9 configurado en <code>\"start\"</code> en el <code>package.json</code>. Por ejemplo, podr\u00eda ser algo como node <code>server.js</code>, <code>nodemon app.js</code>, o cualquier otro comando que se especifique en esa l\u00ednea.</p>"},{"location":"actividad_3.3/","title":"Practica 3.3 Despliegue de una aplicaci\u00f3n una aplicaci\u00f3n React en Netlify (PaaS)","text":""},{"location":"actividad_3.3/#creacion-de-nuestra-aplicacion","title":"Creaci\u00f3n de nuestra aplicaci\u00f3n","text":"<p>Despu\u00e9s de iniciar sesi\u00f3n por SSH en nuestro Debian, creamos una carpeta para la aplicaci\u00f3n con el nombre que prefiramos. Dentro de esa carpeta, a\u00f1adimos los 3 archivos necesarios: dos <code>.html</code> y un <code>.js</code> para nuestra sencilla app de ejemplo.</p> <p>El directorio se puede crear con el comando <code>mkdir</code> como hemos hecho otras veces, mientras que los archivos en cuestion se pueden crear usando el comando <code>sudo nano head.html</code> por ejemplo.</p> <p>head.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n        &lt;h1&gt;Esta es la pagina principal&lt;/h1&gt;\n\n&lt;p&gt;&lt;a href=\"/tailPage\"&gt;Ir a la siguiente pagina&lt;/a&gt;&lt;/p&gt;\n\n\n&lt;/body&gt;\n</code></pre> <p></p> <p>tail.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;h1&gt;FUNCIONA&lt;/h1&gt;\n\n&lt;/body&gt;\n</code></pre> <p></p> <p>aplicacion.js</p> <pre><code>var http = require('http');\nvar fs = require('fs'); // para obtener los datos del archivo html\nvar port = process.env.PORT || 8080; \n\nhttp.createServer(function (req, res) {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n\n    // req.url almacena el path o ruta de la URL\n    var url = req.url;\n    if (url === \"/\") {\n// fs.readFile busca el archivo HTML\n// el primer par\u00e1metro es el path al archivo HTML\n// y el segundo es el callback de la funci\u00f3n\n// si el archivo no se encuentra, la funci\u00f3n devuelve un error\n// si el archivo se encuentra, el contenido del mismo se encuentra en pgres    \n        fs.readFile(\"head.html\", function (err, pgres) {\n            if (err)\n                res.write(\"HEAD.HTML NOT FOUND\");\n            else {\n                // Las siguientes 3 lineas\n                // tienen la funci\u00f3n de enviar el archivo html\n                // y finalizar el proceso de respuesta\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n    else if (url === \"/tailPage\") {\n        fs.readFile(\"tail.html\", function (err, pgres) {\n            if (err)\n                res.write(\"TAIL.HTML NOT FOUND\");\n            else {\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n\n}).listen(port, function () {\n    console.log(\"SERVER STARTED PORT: 8080\");\n});\n</code></pre> <p></p> <p>A continuaci\u00f3n, creamos el archivo <code>package.json</code> con el siguiente comando:</p> <p><code>npm init</code></p> <p></p> <p>Y podemos probar si funciona:</p> <p><code>node aplicacion.js</code></p> <p>Tras hacer eso, deber\u00edamos poder acceder con nuestra m\u00e1quina anfitriona a <code>http://IP-maq-virtual:8080</code></p> <p> </p>"},{"location":"actividad_3.3/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Utilizaremos una aplicaci\u00f3n de ejemplo para esta pr\u00e1ctica.</p> <p>Simplemente, clonaremos el siguiente repositorio con el comando:</p> <p><code>git clone https://github.com/StackAbuse/color-shades-generator</code></p> <p></p>"},{"location":"actividad_3.3/#proceso-de-despliegue-en-netlify","title":"Proceso de despliegue en Netlify","text":"<p>Veremos dos m\u00e9todos de despliegue en Netlify, el primero ser\u00e1 el despliegue manual desde el CLI de Netlify, y el otro ser\u00e1 con conexi\u00f3n a un c\u00f3digo publicado en Github.</p> <p>Tened en cuenta que deb\u00e9is haceros una cuenta en Netlify.</p>"},{"location":"actividad_3.3/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Una vez estemos registrados, instalamos el CLI de Netlify:</p> <p><code>sudo npm install netlify-cli -g</code></p> <p></p> <p>Pedir\u00e1 autentificaci\u00f3n, lo haremos con el comando:</p> <p><code>netlify login</code></p> <p>Como estamos conectados por SSH, podemos generar un token desde Netlify, y lo establecemos como variable de ambiente:</p> <p></p> <p></p> <p>Y ya podremos logearnos con</p> <p><code>netlify login</code></p> <p>Como buenos desarrolladores, haremos un build de la aplicaci\u00f3n para antes de desplegarla.</p> <p>Primero debemos instalar las dependencias indicadas en el archivo <code>package.json</code>:</p> <p><code>npm install</code></p> <p></p> <p>Y cuando lo tengamos procedemos al build:</p> <p><code>npm run build</code></p> <p></p> <p>Esto nos crea la carptea <code>build</code> que contendr\u00e1 la aplicaci\u00f3n a desplegar.</p> <p>Haremos un pre-deploy de la app con el siguiente comando:</p> <p><code>netlify deploy</code></p> <p></p> <p>Nos har\u00e1 unas cuantas preguntas para el despliegue:</p> <ul> <li> <p>Indicamos que queremos crear y configurar una nueva site.</p> </li> <li> <p>El Team se deja por defecto.</p> </li> <li> <p>El nombre para la web ser\u00e1 <code>nombre-practica3-4</code> y el directorio que utilizaremos ser\u00e1 <code>./build</code>.</p> </li> </ul> <p>Si nos indica que todo ha ido bien e incluso podemos ver el \"borrador\" (Website Draft URL) de la web que nos aporta, podemos pasarla a producci\u00f3n finalmente tal y como nos indica la misma salida del comando:</p> <pre><code>If everything looks good on your draft URL, deploy it to your main site URL with the --prod flag.\nnetlify deploy --prod\n</code></pre> <p></p> <p>No olvideis desplegar finalmente para poder comprobar que se puede acceder a la URL:</p> <p></p>"},{"location":"actividad_3.3/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>primero eliminamos la site que hemos desplegado en Netlify para evitar conflictos:</p> <p></p> <p>Luego borramos el directorio donde hemos clonado el repositorio para empezar de 0:</p> <p><code>rm -rf directorio_repositorio</code></p> <p>A continuaci\u00f3n, descargamos un <code>.zip</code> sin que tenga referencia a Github:</p> <p><code>wget https://github.com/StackAbuse/color-shades-generator/archive/refs/heads/main.zip</code></p> <p></p> <p>Y creamos la carpeta nueva para descomprimir el .zip all\u00ed:</p> <pre><code>mkdir practica3.4\n\nunzip main.zip -d practica3.4/\n</code></pre> <p></p> <p>Ya podemos entrar en la carptea donde est\u00e1 el c\u00f3digo:</p> <p><code>cd practica3.4/color-shades-generator-main/</code></p> <p>Ahora deberemos crear un repositorio completamente vac\u00edo en Github que se llame <code>practicaTresCuatro</code>.</p> <p>Y tras hacerlo, volvemos a la terminal para iniciar el repositorio que queremos subir:</p> <pre><code>$ git init\n$ git add .\n$ git commit -m \"Subiendo el c\u00f3digo...\"\n$ git branch -M main\n</code></pre> <p></p> <p>Y ya solo queda hacer referencia al reci\u00e9n creado Github para hacer un <code>push</code>:</p> <pre><code>$ git remote add origin https://github.com/username/practicaTresCuatro.git\n$ git push -u origin main\n</code></pre> <p></p> <p>Con el c\u00f3digo subido a Github, ahora lo que tenemos que hacer es vincular nuestra cuenta de Github con Netlify. Al hacerlo, pedir\u00e1 permisos y nosotros lo autorizaremos, pero un detalle a tener en cuenta es que cuando pregunte sobre qu\u00e9 repositorios instalar, solo elegimos el que hemos hecho para la pr\u00e1ctica.</p> <p></p> <p>Y ya lo tendremos todo listo.</p> <p></p> <p>Luego estaremos listos para desplegar la aplicaci\u00f3n.</p> <p></p> <p>Netlify se encargar\u00e1 de hacer el <code>build</code> de forma autom\u00e1tica tal y como hemos visto en la imagen de arriba, con el comando <code>npm run build</code>, publicando el contenido del directorio <code>build</code>.</p> <p>Con esta conexi\u00f3n, cualquier cambio que hagamos en el proyecto y al que le hagamos un <code>commit</code> y <code>push</code> desde Github, se actualizar\u00e1 automaticamente en Netlify.</p>"},{"location":"actividad_3.3/#comprobacion-de-que-funciona-asi","title":"Comprobaci\u00f3n de que funciona as\u00ed:","text":"<ul> <li>Dentro de la carpeta <code>public</code> existe el archivo <code>robots.txt</code>, que indica a los rastreadores de los buscadores qu\u00e9 URLs pueden acceder. Se puede acceder a trav\u00e9s de la site en s\u00ed.</li> </ul> <ul> <li>Lo que vamos a hacer es acceder la carpeta <code>public</code> donde se encuentra el archivo <code>robots.txt</code> para modificarlo, a\u00f1adiendo <code>nombre_apellido</code> en la secci\u00f3n de Disallow.</li> </ul> <ul> <li> <p>Haremos un nuevo <code>commit</code> y <code>push</code> tal y como lo hemos hecho antes.</p> </li> <li> <p>Y comprobaremos que tanto en la consola como en Netlify hay un nuevo deploy de la app.</p> </li> </ul> <p></p> <p></p> <ul> <li>Por \u00faltimo, accedemos a la url <code>https://url_de_la_aplicacion/robots.txt</code> y comprobamos que el cambio se ha reflejado.</li> </ul> <p></p>"},{"location":"actividad_3.4/","title":"Practica 3.4 Despliegue de una aplicaci\u00f3n Flask (Python)","text":""},{"location":"actividad_3.4/#procedimiento-completo-para-el-despliegue","title":"Procedimiento completo para el despliegue","text":"<p>Primero instalamos el gestor de paquetes de Python pip:</p> <p><code>sudo apt update</code></p> <p><code>sudo apt install python3-pip</code></p> <p></p> <p>Luego instalamos el paquete <code>pipenv</code> para gestionar los entornos virtuales:</p> <p><code>sudo apt install pipenv</code></p> <p></p> <p>Y comprobamos que est\u00e1 instalado correctamente mostrando su versi\u00f3n:</p> <p><code>pipenv --version</code></p> <p></p> <p>Creamos el directorio en el que almacenaremos nuestro proyecto:</p> <p><code>sudo mkdir /var/www/nombre_mi_aplicacion</code></p> <p>Cuando lo creamos con <code>sudo</code>, los permisos pertenecer\u00e1n a root, por lo que debemos cambiarlos para darle los permisos a nuestro usuario (<code>lara</code> en mi caso), y que pertenezca al grupo <code>www-data</code>, con los siguientes comandos:</p> <p><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion</code></p> <p><code>chmod -R 775 /var/www/mi_aplicacion</code></p> <p></p> <pre><code>Es indispensable que asignemos los permisos para que no haya errores.\n</code></pre> <p>A continuaci\u00f3n, dentro del directorio de nuestra aplicaci\u00f3n, creamos un archivo oculto <code>.env</code> que contendr\u00e1 las variables necesarias:</p> <p><code>touch .env</code></p> <p></p> <p>Editamos el archivo y a\u00f1adimos las variables, indicando cu\u00e1l es el archivo <code>.py</code> de la aplicaci\u00f3n y el entorno, que en nuestro caso ser\u00e1 producci\u00f3n:</p> <p></p> <p>Ahora vamos ya a iniciar nuestro entorno virtual con el siguiente comando:</p> <p><code>pipenv shell</code></p> <p>Si todo va bien, el nombre del entorno virtual debe salir antes del nombre y ruta en consola:</p> <p></p> <p>Desde dentro del entorno virtual, instalamos las dependencias necesarias para el proyecto:</p> <p><code>pipenv install flask gunicorn</code></p> <p></p> <p>El archivo que contendr\u00e1 la aplicaci\u00f3n propiamente dicha ser\u00e1 <code>application.py</code>, y <code>wsgi.py</code> se encargar\u00e1 \u00fanicamente de iniciarla y dejarla corriendo:</p> <p><code>touch application.py wsgi.py</code></p> <p>Una vez creamos los archivos, debemos editarlos para dejarlos as\u00ed:</p> <p></p> <p></p> <p>Con el servidor web integrado de Flask, vamos a correr la aplicaci\u00f3n para comprobar que todo funciona bien. Especificaremos la direcci\u00f3n 0.0.0.0:</p> <p></p> <p>Si intentamos entrar en la url, deber\u00eda funcionarnos. Recordad ponerlo de manera que <code>http://IP-maq-virtual:5000</code></p> <p></p> <p>\u00a1Y voil\u00e1! Una vez lo hemos comprobado, paramos el servidor con <code>CTRL+C</code>.</p>"},{"location":"actividad_3.4/#comprobacion-de-gunicorn","title":"Comprobaci\u00f3n de Gunicorn","text":"<p>Si Flask ha funcionado bien, usando el siguiente comando nos dir\u00e1 si Gunicorn funciona:</p> <p><code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app</code></p> <p></p> <p>Todav\u00eda en el entorno virtual, vamos a tomar nota del path desde la que se ejecuta <code>gunicorn</code>, la vamos a necesitar para m\u00e1s adelante:</p> <p></p> <p>Como ya tendr\u00edamos que tener Nginx instalado en nuestro sistema por practicas anteriores, lo iniciamos y comprobamos su estado:</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p></p> <p>Ya fuera del entorno virtual, creamos un archivo para systemd, para que corra Gunicorn como un servicio m\u00e1s:</p> <p></p> <p>Tened en cuenta que:</p> <ul> <li> <p><code>User</code>: Ser\u00e1 nuestro usuario.</p> </li> <li> <p><code>Group</code>: Pondremos <code>www-data</code></p> </li> <li> <p><code>Environment</code>: Establecemos el directorio <code>bin</code>. La ruta que guardamos antes pero sin el 'gunicorn'.</p> </li> <li> <p><code>WorkingDirectory</code>: El directorio donde tenemos el proyecto.</p> </li> <li> <p><code>ExecStart</code>: La ruta que guardamos antes para Gunicorn, completa.</p> </li> </ul> <p>Una vez configurado eso, habilitamos el servicio:</p> <pre><code>systemctl enable nombre_mi_servicio\n\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>El nombre del servicio es el nombre del archivo que creamos antes.</p> <p>Ahora deberemos configurar Nginx, yendo a la ruta de <code>/etc/nginx/sites-available/nombre_aplicacion</code>:</p> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion; \n\n\n\n    access_log /var/log/nginx/mi_aplicacion.access.log; \n\n\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock; \n\n\n    }\n}   \n</code></pre> <p></p> <p>Recordemos que ahora debemos crear un link simb\u00f3lico del archivo de sitios webs disponibles al de sitios web activos:</p> <p><code>sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/</code></p> <p>Y nos aseguramos de que se ha creado dicho link simb\u00f3lico:</p> <p><code>ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion</code></p> <p></p> <p>Como siempre, comprobamos que no haya errores y reiniciamos Nginx:</p> <pre><code>nginx -t\n\nsudo systemctl restart nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Como ya no podemos acceder por IP ya que la app est\u00e1 siendo servida por Gunicorn y Nginx, accedemos por el <code>server_name</code>.</p> <p>Debemos editar el archivo <code>hosts</code> de la m\u00e1quina anfitriona para a\u00f1adir la IP de la m\u00e1quina virtual y el nombre del proyecto:</p> <p></p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code></p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></p> <p>Ya guardado el archivo <code>hosts</code>, intentamos acceder a la web a trav\u00e9s de <code>http://nombre_aplicacion</code> o <code>http://www.nombre_aplicacion</code>:</p> <p></p> <p></p>"},{"location":"actividad_3.4/#mismo-proceso-con-un-repositorio-de-git","title":"Mismo proceso con un repositorio de Git","text":"<p>Primero, comenzamos con clonar el repositorio en cuesti\u00f3n:</p> <p><code>git clone https://github.com/raul-profesor/Practica-3.5</code></p> <p></p> <p>Lo siguiente que debemos hacer es dar los permisos necesarios a nuestra aplicaci\u00f3n, tal y como hicimos anteriormente, con los comandos, y siempre teniendo en cuenta que esta vez el nombre de la aplicaci\u00f3n es diferente:</p> <pre><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion\n\nchmod -R 775 /var/www/mi_aplicacion   \n</code></pre> <p></p> <p>Dentro del directorio de la app, creamos el archivo oculto <code>.env</code> para la creaci\u00f3n de otro entorno virtual:</p> <p><code>touch .env</code></p> <p>Y editamos el archivo para que quede as\u00ed:</p> <p></p> <p>Lanzamos el entorno virtual:</p> <p><code>pipenv shell</code></p> <p></p> <p>E instalamos las dependencias correspondientes:</p> <p><code>pipenv install -r requirements.txt</code></p> <p><code>pipenv install flask gunicorn</code></p> <p></p> <p></p> <p>Creamos el archivo <code>wsgi.py</code> solo ya que el otro no hace falta al existir ya uno:</p> <p><code>touch wsgi.py</code></p> <p>Y lo editamos para dejarlo as\u00ed:</p> <p></p> <p>Ya creado y guardado, probamos que lo corre, usando la direcci\u00f3n <code>0.0.0.0</code> como la otra vez:</p> <p><code>flask run --host '0.0.0.0'</code></p> <p>Y al entrar en la url <code>http://IP-maq-virtual:5000</code> deber\u00eda verse lo siguiente:</p> <p></p>"},{"location":"actividad_3.4/#comprobaacion-de-gunicorn-2","title":"Comprobaaci\u00f3n de Gunicorn 2","text":"<p>Si Flask ha funcionado bien, usando el siguiente comando nos dir\u00e1 si Gunicorn funciona:</p> <p><code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app</code></p> <p></p> <p>Todav\u00eda en el entorno virtual, vamos a tomar nota del path desde la que se ejecuta <code>gunicorn</code>, la vamos a necesitar para m\u00e1s adelante:</p> <p></p> <p>Como ya tendr\u00edamos que tener Nginx instalado en nuestro sistema por practicas anteriores, lo iniciamos y comprobamos su estado:</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Ya fuera del entorno virtual, creamos un archivo para systemd, para que corra Gunicorn como un servicio m\u00e1s:</p> <p></p> <p>Tened en cuenta que:</p> <ul> <li> <p><code>User</code>: Ser\u00e1 nuestro usuario.</p> </li> <li> <p><code>Group</code>: Pondremos <code>www-data</code></p> </li> <li> <p><code>Environment</code>: Establecemos el directorio <code>bin</code>. La ruta que guardamos antes pero sin el 'gunicorn'.</p> </li> <li> <p><code>WorkingDirectory</code>: El directorio donde tenemos el proyecto.</p> </li> <li> <p><code>ExecStart</code>: La ruta que guardamos antes para Gunicorn, completa.</p> </li> </ul> <p>Una vez configurado eso, habilitamos el servicio:</p> <pre><code>systemctl enable nombre_mi_servicio\n\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>El nombre del servicio es el nombre del archivo que creamos antes.</p> <p>Ahora deberemos configurar Nginx, yendo a la ruta de <code>/etc/nginx/sites-available/nombre_aplicacion</code>:</p> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion; \n\n\n\n    access_log /var/log/nginx/mi_aplicacion.access.log; \n\n\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock; \n\n\n    }\n}   \n</code></pre> <p></p> <p>Recordemos que ahora debemos crear un link simb\u00f3lico del archivo de sitios webs disponibles al de sitios web activos:</p> <p><code>sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/</code></p> <p>Y nos aseguramos de que se ha creado dicho link simb\u00f3lico:</p> <p><code>ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion</code></p> <p>Como siempre, comprobamos que no haya errores y reiniciamos Nginx:</p> <pre><code>nginx -t\n\nsudo systemctl restart nginx\n\nsudo systemctl status nginx\n</code></pre> <p>Como ya no podemos acceder por IP ya que la app est\u00e1 siendo servida por Gunicorn y Nginx, accedemos por el <code>server_name</code>.</p> <p>Debemos editar el archivo <code>hosts</code> de la m\u00e1quina anfitriona para a\u00f1adir la IP de la m\u00e1quina virtual y el nombre del proyecto:</p> <p></p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code></p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></p> <p>Ya guardado el archivo <code>hosts</code>, intentamos acceder a la web a trav\u00e9s de <code>http://nombre_aplicacion</code> o <code>http://www.nombre_aplicacion</code>:</p> <p></p>"},{"location":"actividad_3.4/#cuestiones","title":"Cuestiones","text":"<pre><code>Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI.\n</code></pre> <p>Un servidor WSGI es como el intermediario que traduce entre un servidor web (como Nginx o Apache) y una aplicaci\u00f3n web hecha en Python (por ejemplo, Flask o Django). Recibe las solicitudes del navegador, las convierte en algo que la aplicaci\u00f3n entiende, y luego toma la respuesta de la aplicaci\u00f3n y se la devuelve al cliente en un formato listo para la web. Este est\u00e1ndar hace que cualquier servidor WSGI pueda trabajar con cualquier aplicaci\u00f3n Python compatible, facilitando el despliegue en producci\u00f3n, especialmente con herramientas como Gunicorn o uWSGI, que manejan m\u00faltiples solicitudes al mismo tiempo para maximizar el rendimiento.</p>"},{"location":"ampliacion/","title":"Pr\u00e1ctica de Ampliaci\u00f3n","text":""},{"location":"ampliacion/#configuracion-de-un-servidor-nginx-con-hosts-virtuales-y-directorios-de-usuario","title":"Configuraci\u00f3n de un servidor Nginx con Hosts Virtuales y directorios de usuario","text":"<p>Como para esta pr\u00e1ctica se han reutilizado m\u00e1quinas virtuales que ya estaban configuradas para este tipo de cosas, hay algunos pasos que no han sido detallados, pero aun as\u00ed ser\u00e1n mencionados.</p>"},{"location":"ampliacion/#maquina-virtual-con-debian","title":"M\u00e1quina Virtual con Debian","text":"<p>En mi caso ya ten\u00eda una configurada, as\u00ed que simplemente la clon\u00e9 para trabajar desde una nueva, indicando que generase nuevas IP y as\u00ed no mezclarse con la otra.</p>"},{"location":"ampliacion/#conexion-por-ssh","title":"Conexi\u00f3n por SSH","text":"<p>Para conectarnos a nuestra m\u00e1quina virtual por SSH, todo lo que tenemos que hacer es abrir la consola de comandos e introducir el siguiente comando, donde la IP debe corresponder a la de la m\u00e1quina virtual, no la de la m\u00e1quina anfitriona:</p> <pre><code>ssh &lt;usuario&gt;@192.168.137.31\n</code></pre> <p>Una vez conectados podemos manejarlo todo desde esa consola.</p>"},{"location":"ampliacion/#instalacion-de-nginx","title":"Instalaci\u00f3n de Nginx","text":"<p>En mi caso, Nginx ya estaba instalado, pero para comprobar que todo estaba bien, utilic\u00e9 el siguiente comando para comprobar que funcionando:</p> <pre><code>systemctl status nginx\n</code></pre> <p></p> <p></p> <p>De todas formas, si hiciese falta instalar Nginx en s\u00ed, lo mejor y m\u00e1s r\u00e1pido es instalarlo a trav\u00e9s del gestor de paquetes con los siguientes comandos:</p> <pre><code>sudo apt-get update \nsudo apt-get upgrade \nsudo apt-get install nginx\n</code></pre> <p>No har\u00eda falta configurar nada m\u00e1s, ya que la configuraci\u00f3n que viene por defecto deber\u00eda ser suficiente para esta pr\u00e1ctica.</p>"},{"location":"ampliacion/#creacion-de-usuarios-del-sistema","title":"Creaci\u00f3n de usuarios del sistema","text":"<p>Para la pr\u00e1ctica vamos a crear dos usuarios diferentes de manera sencilla.</p> <p>Haremos usuarios b\u00e1sicos, ya que no hace falta mucho m\u00e1s para esta actividad. Para ello, lo que s\u00ed vamos a tener en cuenta es que m\u00e1s adelante crearemos carpetas para cada usuario.</p> <p>Para la creaci\u00f3n del usuario, debemos utilizar los siguientes comandos:</p> <pre><code>sudo useradd -m -s /bin/bash &lt;usuario&gt;\nsudo passwd &lt;usuario&gt;\n</code></pre> <p></p> <p>Obviamente, debemos usar los comandos dos veces para crear dos usuarios esta vez.</p>"},{"location":"ampliacion/#estructura-de-carpetas","title":"Estructura de carpetas","text":"<p>Lo pr\u00f3ximo ser\u00eda crear una carpeta por usuario nuevo para que cada uno tenga su web. Como Nginx intenta acceder a <code>public_html</code> (que es como se llama por defecto la carpeta donde estar\u00e1 la p\u00e1gina web), crearemos esta carpeta para cada usuario.</p> <p>Para ello debemos seguir los siguientes pasos:</p> <ul> <li>Iniciamos sesi\u00f3n con el primer usuario y revisamos que estamos en su home.</li> </ul> <pre><code>su &lt;usuario&gt;\ncd\n</code></pre> <ul> <li>Creamos la carpeta de <code>public_html</code>.</li> </ul> <pre><code>mkdir public_html\n</code></pre> <ul> <li>Para dar permisos a Nginx, utilizaremos un comando que nos deja darlos de manera m\u00e1s r\u00e1pida:</li> </ul> <pre><code>setfacl -d -R -m u:www-data:rw public_html\n</code></pre> <p>Ten en cuenta que estos pasos se deben seguir DOS veces. Para configurarlo en los dos nuevos usuarios.</p> <p>Y para comprobar que funciona y que se tienen los permisos necesarios, podemos comprobarlo con el siguiente comando:</p> <pre><code>getfacl &lt;ruta_de_carpeta&gt;\n</code></pre> <p></p> <p></p>"},{"location":"ampliacion/#contenido-web","title":"Contenido web","text":"<p>Como lo \u00fanico que crearemos ser\u00e1n p\u00e1ginas web sencillas para ver que funciona, vamos a crear un archivo <code>index.html</code> para cada usuario en la carpeta de <code>public_html</code>.</p> <p>Para ello, debemos iniciar sesi\u00f3n con el usuario en s\u00ed, siguiendo los mismos comandos de antes, y una vez en la carpeta, utilizamos el comando <code>nano index.html</code> para crear el archivo en s\u00ed.</p> <p></p> <p>Pod\u00e9is poner lo que quer\u00e1is, pero la estructura b\u00e1sica a seguir es la siguiente:</p> <p></p> <p></p>"},{"location":"ampliacion/#creacion-de-los-hosts-virtuales","title":"Creaci\u00f3n de los hosts virtuales","text":"<p>Crearemos unos archivos para que desde HTTP nos redirija a HTTPS.</p> <p>Para ello, deberemos ir a la carpeta de sitios web disponibles en <code>/etc/nginx/sites-available/nombre_de_la_web</code> y entrar en una de ellas. Recordad que debemos seguir los pasos x2 al tener dos usuarios y dos webs diferentes.</p> <p>Una vez dentro, utilizamos el comando <code>sudo nano &lt;nombre&gt;</code> para crear un archivo que tendr\u00e1 la siguiente configuraci\u00f3n:</p> <pre><code># Este bloque es la configuraci\u00f3n para el host en puerto 443\nserver {\n\n    listen 443 ssl; \n    listen [::]:443 ssl;\n\n    root &lt;direccion_raiz_servidor&gt;;\n\n    ssl_certificate &lt;direccion_certificado_tls-ssl&gt;;\n    ssl_certificate_key &lt;direccion_clave_privada_certificado_tls-ssl&gt;;\n\n    index index.html;\n\n    server_name &lt;nombre_host&gt;; \n\n    location / {\n        return 301 https://$host:$request_uri; \n    }\n}\n\n# Este bloque hace referencia a la redirecci\u00f3n\nserver {\n\n    listen 80; \n    listen [::]:80;\n\n    server_name &lt;nombre_host&gt;; \n\n    location / {\n        return 301 https://$host:$request_uri; \n    }\n}\n</code></pre> <p></p> <p></p> <p>Una vez hecho eso, debemos crear los enlaces simb\u00f3licos para 'activar' las webs en <code>/etc/nginx/sites-enabled/</code>, las cuales tambi\u00e9n debemos repetir dos veces para las dos webs.</p> <pre><code>sudo ln -s /etc/nginx/sites-available/&lt;archivo_de_configuraci\u00f3n&gt; /etc/nginx/sites-enabled\n</code></pre> <p>Y para comprobar que todo est\u00e1 correcto:</p> <pre><code>sudo nginx -t\n</code></pre> <p>Una vez comprobado que todo est\u00e1 bien, se reinicia Nginx:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p></p> <p></p>"},{"location":"ampliacion/#configurar-el-archivo-hosts","title":"Configurar el archivo hosts","text":"<p>Como en pr\u00e1cticas anteriores, debemos a\u00f1adir los dominios e IPs de nuestros servidores para que se haga referencia a la m\u00e1quina virtual.</p> <p>Para ello, solo debemos abrir el archivo <code>hosts</code>, que en mi caso (Windows) se encuentra en <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> y a\u00f1adir la IP de la m\u00e1quina virtual y los nombres de los dominios.</p> <p></p>"},{"location":"ampliacion/#generacion-de-certificados-para-https","title":"Generaci\u00f3n de certificados para HTTPS","text":"<p>Para que la web sirva con HTTPS, necesitamos certificados, pero como esto es una pr\u00e1ctica y no una web real, generaremos un certificado para cada usuario que hemos creado.</p> <p>Yo ya ten\u00eda alg\u00fan certificado de antes, pero por si acaso, gener\u00e9 uno por usuario para no pillarme los dedos.</p> <p>Podemos hacerlo con el siguiente comando, gener\u00e1ndolos en el directorio <code>/etc/ssl/certs</code> y la clave correspondiente en <code>/etc/ssl/private</code>:</p> <pre><code>openssl req -x509 -newkey rsa:4096 -keyout &lt;private_key_file&gt; -out &lt;certificate_file&gt; -sha256 -days 365 --nodes\n</code></pre> <p>Deber\u00eda quedar algo as\u00ed:</p> <p></p> <p></p>"},{"location":"ampliacion/#comprobacion-final","title":"Comprobaci\u00f3n final","text":"<p>Una vez hecho todo lo anterior, deber\u00edamos poder acceder a los dominios y ser redirigidos a su versi\u00f3n HTTPS, al igual que cada web deber\u00eda mostrar su propio certificado:</p> <p></p> <p></p> <p></p> <p></p>"}]}